<html>
<head>
<style>
.link {
	stroke: #999;
}
.forcevec {
	stroke: red;
}
svg {
	border: 1px solid black;
}
svg polygon.corner {
	fill: #ffdd60;
	pointer-events: none;
}
svg text.label {
	pointer-events: none;
}
#controls label {
	display: inline-block;
	width: 120px;
	text-align: right;
}
</style>
</head>
<body>
<div id="pmap">
</div>
<div id="controls">
<p>
	<label for="springCoupling">Spring coupling</label>
	<input type="range" min="0.2" max="8" id="springCoupling" value="1" step="0.2" />
	<span id="springCouplingValue">1</span>
</p>
<p>
	<label for="springLength">Spring length</label>
	<input type="range" min="0.4" max="3" id="springLength" value="1" step="0.2" />
	<span id="springLengthValue">1</span>
</p>
<p>
	<label for="repulsionPower">Repulsion power</label>
	<input type="range" min="0.4" max="2" id="repulsionPower" value="1" step="0.1" />
	<span id="repulsionPowerValue">1</span>
</p>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.1/d3.min.js"></script>
<script src="force.js"></script>
<script>


var nodes = [{x: 1., y: 0.}, {x: 0.309017, y: 0.951057}, {x: -0.809017, y: 0.587785}, 
			 {x: -0.809017, y: -0.587785}, {x: 0.309017, y: -0.951057}, {x: 0.4, y: 0.2}, 
			 {x: 2., y: 0.}, {x: 2., y: 3.}, {x: 1., y: 1.}, {x: 1.2, y: 1.}
			].map(function(p){return {pos: new Vec2(p.x,p.y)};});
		 
var links = [ [0,1], [1,2], [2,3], [3,4], [4,0], 
			  [0,5], [4,6], [6,0], [1,7], [7,2], 
			  [6,7], [0,8], [8,9], [9,0] ];
var faces = [{links: [{id:0,ccw:true}, {id:1,ccw:true}, {id:2,ccw:true}, {id:3,ccw:true}, 
					  {id:4,ccw:true}, {id:5,ccw:true},{id:5,ccw:false}], 
			  outer: false,
			  color: "#f0f0ff"}, 
			 {links: [{id:4,ccw:false},{id:6,ccw:true},{id:7,ccw:true}], 
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:8,ccw:true},{id:9,ccw:true},{id:1,ccw:false}],
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:7,ccw:false},{id:10,ccw:true},{id:8,ccw:false},{id:0,ccw:false},
			 		  {id:11,ccw:true},{id:12,ccw:true},{id:13,ccw:true}], 
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:13,ccw:false},{id:12,ccw:false},{id:11,ccw:false}],
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:9,ccw:false},{id:10,ccw:false},{id:6,ccw:false},
			 		  {id:3,ccw:false},{id:2,ccw:false}],
			  outer: true,
			  color: "#f0f0ff"}];

var scale = 60;
var offset = {x: 500, y: 250};
function toScreenCoor(d)
{
	return new Vec2(scale*d.x + offset.x,-scale*d.y + offset.y);
}
function fromScreenCoor(c)
{
	return new Vec2((c.x-offset.x)/scale,(-c.y+offset.y)/scale);
}

var svg = d3.select("#pmap").append("svg")
	.attr("width",1000).attr("height",500);


var force = CMap.force().nodes(nodes)
	.faces(faces)
	.links(links)
	.clip({use: false, minX: fromScreenCoor({x:0,y:svg.attr("height")}).x,
					  minY: fromScreenCoor({x:0,y:svg.attr("height")}).y,
					  maxX: fromScreenCoor({x:svg.attr("width"),y:0}).x,
					  maxY: fromScreenCoor({x:svg.attr("width"),y:0}).y})
	.centerPull({pull: true, center: new Vec2(0,0), coupling: 0.4})
	.on("tick",updateMap);

d3.select("#springCoupling").on("input",function(){updateSpringCoupling(+this.value);});
function updateSpringCoupling(x) {
	force.springCoupling(x);
	d3.select("#springCoupling").property("value",x);
	d3.select("#springCouplingValue").text(x);
	force.resume();	
}	
d3.select("#springLength").on("input",function(){updateSpringLength(+this.value);});
function updateSpringLength(x) {
	force.springLength(x);
	d3.select("#springLength").property("value",x);
	d3.select("#springLengthValue").text(x);
	force.resume();		
}	
d3.select("#repulsionPower").on("input",function(){updateRepulsionPower(+this.value);});
function updateRepulsionPower(x) {
	force.repulsionPower(x);
	d3.select("#repulsionPower").property("value",x);
	d3.select("#repulsionPowerValue").text(x);	
	force.resume();	
}		


var facegroup = svg.append("g").attr("class","facegroup");

var facePolygons = facegroup.selectAll("polygon")
	.data(faces.filter(function(f) { return !f.outer; }))
	.enter().append("polygon")
	.attr("fill",function(d){return d.color;} )
	.attr("fill-opacity",0)
	.attr("stroke","")
	.on("mouseover",function(d,i) { d3.select(this).style("fill-opacity",1);})
	.on("mouseout",function(d,i) { removeCorners(); d3.select(this).style("fill-opacity",0);})
	.on("mousemove",polygonMouseMove)
	.on("click",polygonClick);

var corners = [];
var cornergroup = svg.append("g").attr("class","cornergroup");
var cornerPolygon = cornergroup.selectAll("polygon.corner")
	.data(corners);

var linkgroup = svg.selectAll("g.face")
	.data(faces)
	.enter()
	.append("g")
	.attr("class","face");

var linkLines = linkgroup.selectAll("line.link")
	.data(function(d) { return d.links;	})
	.enter().append("line")
	.attr("class","link");

var drag = d3.behavior.drag()
	.origin(function(d){return d;})
	.on("drag", dragmove)
	.on("dragstart", dragstart)
	.on("dragend", dragend);
	
var nodeGroups = svg.selectAll("g.node")
   	.data(nodes)
   	.enter()
   	.append("g")
   	.attr("class","node");
   	
var nodeCircles = nodeGroups.append("circle")
   	.attr("class","node")
   	.attr("r", "7px")
   	.attr("fill", "blue")
 	.call(drag);
var nodeLabels = nodeGroups.append("text")
	.attr("dx",9)
	.attr("class","label")
	.style("text-anchor","start")
	.text(function(d,i) {return i;});

function updateNodes()
{
	linkgroup = svg.selectAll("g.face")
		.data(faces);
	
	linkgroup
		.enter()
		.append("g")
		.attr("class","face");
	
	linkLines = linkgroup.selectAll("line.link")
		.data(function(d) { return d.links;	});
		
	linkLines
		.enter().append("line")
		.attr("class","link");  
	
	nodeGroups = svg.selectAll("g.node")
	   	.data(nodes);
	   	
	nodeGroups
	   	.enter()
	   	.append("g")   	
	   	.attr("class","node");
	   	
	nodeCircles = nodeGroups.append("circle")
	   	.attr("class","node")
	   	.attr("r", "7px")
	   	.attr("fill", "blue")
	 	.call(drag);
	 	
	nodeLabels = nodeGroups.append("text")
		.attr("dx",9)
		.attr("class","label")
		.style("text-anchor","start")
		.text(function(d,i) {return i;});
		
	nodeCircles = nodeGroups.select("circle");
	nodeLabels = nodeGroups.select("text");	
	
 
}
function updateLinks()
{
	
}

function dragstart(d)
{
	force.dragforce().drag = true;
	force.dragforce().node = d;

	var p = d3.mouse(svg.node());
	force.dragforce().cursor = fromScreenCoor({x:p[0],y:p[1]});
	force.resume();
}
function dragmove(d)
{
	var p = d3.mouse(svg.node());
	force.dragforce().cursor = fromScreenCoor({x:p[0],y:p[1]});
	force.resume();
}
function dragend(d)
{
	force.dragforce().drag = false;
}

function polygonMouseMove(d,i)
{
	var p = d3.mouse(svg.node());
	var mouse = fromScreenCoor({x:p[0],y:p[1]});
	var mindistSq = 1000;
	var minnode = 0;
	var mincorner = 0;
	d.links.forEach(function(l,i){
		var thisnode = links[l.id][l.ccw?0:1];
		var distSq = mouse.copy().subVec( nodes[thisnode].pos ).normSq();
		if( distSq < mindistSq )
		{
			var prevlink = d.links[(i+d.links.length-1)%d.links.length];
			var prev = nodes[links[prevlink.id][prevlink.ccw?0:1]].pos.copy().subVec(nodes[thisnode].pos);
			var next = nodes[links[d.links[i].id][d.links[i].ccw?1:0]].pos.copy().subVec(nodes[thisnode].pos);
			var curvec = mouse.copy().subVec( nodes[thisnode].pos );
			var angle1 = next.angle(curvec),
				angle2 = next.angle(prev);
			if( angle1 <= 0.001 ) angle1 += 2*Math.PI;
			if( angle2 <= 0.001 ) angle2 += 2*Math.PI;
			if( angle1 < angle2 )
			{
				mindistSq = distSq;
				minnode = thisnode;
				mincorner = i;
			}
		}
	});
	
	if( mindistSq < 0.3 )
	{
		var prevlink = d.links[(mincorner+d.links.length-1)%d.links.length];
		var prevnode = links[prevlink.id][prevlink.ccw?0:1];
		var nextnode = links[d.links[mincorner].id][d.links[mincorner].ccw?1:0];
		//removeCorners();
		if( corners.length == 0 )
		{
			corners[0] = { c: nodes[minnode], r: 0.4, prev: nodes[prevnode], next: nodes[nextnode], 
				face: d, faceindex: mincorner, nodeindex: minnode };
			cornerPolygon = cornerPolygon.data(corners);
			cornerPolygon.enter()
				.append("polygon")
				.attr("class","corner");
		} else
		{
			corners[0].c = nodes[minnode];
			corners[0].r = 0.4;
			corners[0].prev = nodes[prevnode];
			corners[0].next = nodes[nextnode];
			corners[0].face = d;
			corners[0].faceindex = mincorner;
			corners[0].nodeindex = minnode;
		}
		cornerPolygon.attr("points",cornerPolygonPoints);
	} else
	{
		removeCorners();
	}
}

function polygonClick(d,i)
{
	if( corners.length == 1 )
	{
		insertEdge(corners[0]);
	}
}

function insertEdge(corner)
{
	var nextvec = corner.next.pos.copy().subVec(corner.c.pos);
	var prevvec = corner.prev.pos.copy().subVec(corner.c.pos);
	var angle = nextvec.angle(prevvec);
	if( angle <= 0.001 ) angle += 2*Math.PI;
	
	var newcoor = nextvec.rotate(0.5*angle).mult(0.2).addVec(corner.c.pos);
	nodes.push({pos: newcoor});
	links.push([corner.nodeindex,nodes.length-1]);
	corner.face.links.splice(corner.faceindex,0,{id:links.length-1,ccw:true},{id:links.length-1,ccw:false});
	updateNodes();
	updateLinks();
	console.assert(!CMap.faceIsNonSimple(corner.face,links,nodes));
	
	removeCorners();
	force.resume();
}

function removeCorners()
{
	while(corners.length > 0) {
		corners.pop();
	}
	cornerPolygon = cornerPolygon.data(corners);
	cornerPolygon.exit().remove();
}

function cornerPolygonPoints(corner)
{
	var coor = [];
	coor.push(corner.c.pos);
	var radial=corner.next.pos.copy().subVec(corner.c.pos).normalize().mult(corner.r);
	var angle = radial.angle(corner.prev.pos.copy().subVec(corner.c.pos));
	if( angle <= 0.0001 ) angle += 2*Math.PI;
	var subdiv = Math.ceil(angle/0.2);
	for( var i=0;i<=subdiv;i++)
	{
		coor.push(radial.copy().rotate(i*angle/subdiv).addVec(corner.c.pos));
	}
	return coor.map(function(p) {
		var scr = toScreenCoor(p);
		return [scr.x,scr.y].join(","); }).join(" ");
}

function updateMap()
{
//	nodeCircles
//   	.attr("cx", function(d) { return toScreenCoor(d.pos).x; })
//   	.attr("cy", function(d) { return toScreenCoor(d.pos).y; });
	nodeGroups.attr("transform", function(d){
		return "translate(" + [toScreenCoor(d.pos).x,toScreenCoor(d.pos).y] + ")";
   	});


	linkLines
	.attr("x1", function(d) { return toScreenCoor(nodes[links[d.id][0]].pos).x; })
	.attr("y1", function(d) { return toScreenCoor(nodes[links[d.id][0]].pos).y; })
	.attr("x2", function(d) { return toScreenCoor(nodes[links[d.id][1]].pos).x; })
	.attr("y2", function(d) { return toScreenCoor(nodes[links[d.id][1]].pos).y; });
	

	cornerPolygon
		.attr("points",cornerPolygonPoints);
	
	/*
	forceLines
	.attr("x1", function(d) { return toScreenCoor(d.pos).x; })
	.attr("y1", function(d) { return toScreenCoor(d.pos).y; })
	.attr("x2", function(d) { return toScreenCoor(d.pos.copy().addVec(d.force.copy().mult(0.02))).x; })
	.attr("y2", function(d) { return toScreenCoor(d.pos.copy().addVec(d.force.copy().mult(0.02))).y; });
	*/
	
	facePolygons.attr("points",function(d) {
		return d.links.map(function(p) { 
			var coor = toScreenCoor(nodes[links[p.id][(p.ccw?0:1)]].pos);
			return [coor.x,coor.y].join(","); 
		}).join(" ");
	});
	
	
	/*facePolygons.attr("fill",function(d) {
		return (CMap.faceIsNonSimple(d,links,nodes) ? "red" : "#ccffcc");
	});*/
}

updateSpringCoupling(1);
updateSpringLength(1);
updateRepulsionPower(1);

</script>
</body>
</html>
