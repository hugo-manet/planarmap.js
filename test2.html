<html>
<head>
<style>
.link {
	stroke: #999;
}
.forcevec {
	stroke: red;
}
svg {
	border: 1px solid black;
}
svg polygon.corner {
	pointer-events: none;
	fill: #dd5020;
}
svg text.label {
	pointer-events: none;
	font-family: Verdana;
	font-size: 14;
}
svg path.link {
	stroke-width: 2;
	stroke: #aaaaaa;
	fill: none;
}
svg line.segmenthelper {
	pointer-events: none;
	stroke-width: 2;
	stroke: #aaaaaa;
	stroke-dasharray: 5,5;
}
svg circle.node {
	cursor:move;
}
#controls label {
	display: inline-block;
	width: 140px;
	text-align: right;
}
</style>
</head>
<body>
<div id="pmap">
</div>
<div id="controls">
<p>
	<label for="springCoupling">Spring coupling</label>
	<input type="range" min="0.2" max="10" id="springCoupling" value="1" step="0.2" />
	<span id="springCouplingValue">1</span>
</p>
<p>
	<label for="springLength">Spring length</label>
	<input type="range" min="0.2" max="2.5" id="springLength" value="1" step="0.1" />
	<span id="springLengthValue">1</span>
</p>
<p>
	<label for="repulsionPower">Repulsion power</label>
	<input type="range" min="0.1" max="3" id="repulsionPower" value="1" step="0.1" />
	<span id="repulsionPowerValue">1</span>
</p>
<p>
	<label for="centerPullCoupling">Center pull coupling</label>
	<input type="range" min="0" max="10" id="centerPullCoupling" value="1" step="0.25" />
	<span id="centerPullCouplingValue">1</span>
</p>
<p>
	<input type="button" id="saveasSVG" value="Save as SVG"/>
</p>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.1/d3.min.js"></script>
<script src="force.js"></script>
<script src="geometry.js"></script>
<script src="thirdparty/crowbar/svg-crowbar.js"></script>
<script>

/*
var nodes = [{x: 1., y: 0.}, {x: 0.309017, y: 0.951057}, {x: -0.809017, y: 0.587785}, 
			 {x: -0.809017, y: -0.587785}, {x: 0.309017, y: -0.951057}, {x: 0.4, y: 0.2}, 
			 {x: 2., y: 0.}, {x: 2., y: 3.}, {x: 1., y: 1.}, {x: 1.2, y: 1.}
			].map(function(p){return {pos: new Vec2(p.x,p.y)};});
		 
var links = [ [0,1], [1,2], [2,3], [3,4], [4,0], 
			  [0,5], [4,6], [6,0], [1,7], [7,2], 
			  [6,7], [0,8], [8,9], [9,0] ];
var edges = [ 0,1,2,3,4,5,6,7,8,9,10,11,12,13 ].map(function(x){return[x];});
var faces = [{links: [{id:0,ccw:true}, {id:1,ccw:true}, {id:2,ccw:true}, {id:3,ccw:true}, 
					  {id:4,ccw:true}, {id:5,ccw:true},{id:5,ccw:false}], 
			  outer: false,
			  color: "#f0f0ff"}, 
			 {links: [{id:4,ccw:false},{id:6,ccw:true},{id:7,ccw:true}], 
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:8,ccw:true},{id:9,ccw:true},{id:1,ccw:false}],
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:7,ccw:false},{id:10,ccw:true},{id:8,ccw:false},{id:0,ccw:false},
			 		  {id:11,ccw:true},{id:12,ccw:true},{id:13,ccw:true}], 
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:13,ccw:false},{id:12,ccw:false},{id:11,ccw:false}],
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:9,ccw:false},{id:10,ccw:false},{id:6,ccw:false},
			 		  {id:3,ccw:false},{id:2,ccw:false}],
			  outer: true,
			  color: "#f0f0ff"}];
var externalface = faces[5];
*/

var nodes = [{ pos: new Vec2(0.5,0)}, {pos: new Vec2(-0.5,0)}];
var links = [ [0,1] ];
var edges = [ [0] ];
var faces = [ {links: [{id:0,ccw:false},{id:0,ccw:true}],
			  outer: true,
			  color: "#d0d0ff"}];
var externalface = faces[0];

var helplines = [];
var corners = [];

var scale = 60;
var offset = {x: 650, y: 450};
function toScreenCoor(d)
{
	//return new Vec2(d.x,d.y);
	return new Vec2(scale*d.x + offset.x,-scale*d.y + offset.y);
}
function fromScreenCoor(c)
{
	//return new Vec2(c.x,c.y);
	return new Vec2((c.x-offset.x)/scale,(-c.y+offset.y)/scale);
}

var svg = d3.select("#pmap").append("svg")
	.attr("id","pmapsvg")
	.attr("width",1300).attr("height",900)
	//.attr("viewBox","-15 -15 15 15")
	//.attr("preserveAspectRatio", "xMidYMid meet");


var force = CMap.force().nodes(nodes)
	.faces(faces)
	.links(links)
	.clip({use: false, minX: fromScreenCoor({x:0,y:svg.attr("height")}).x,
					  minY: fromScreenCoor({x:0,y:svg.attr("height")}).y,
					  maxX: fromScreenCoor({x:svg.attr("width"),y:0}).x,
					  maxY: fromScreenCoor({x:svg.attr("width"),y:0}).y})
	.centerPull({pull: true, center: new Vec2(0,0), coupling: 0.4})
	.on("tick",updateMap)
	.on("end",updateMap);

d3.select("#springCoupling").on("input",function(){updateSpringCoupling(+this.value);});
function updateSpringCoupling(x) {
	force.springCoupling(x);
	d3.select("#springCoupling").property("value",x);
	d3.select("#springCouplingValue").text(x);
	force.resume();	
}	
d3.select("#springLength").on("input",function(){updateSpringLength(+this.value);});
function updateSpringLength(x) {
	force.springLength(x);
	d3.select("#springLength").property("value",x);
	d3.select("#springLengthValue").text(x);
	force.resume();		
}	
d3.select("#repulsionPower").on("input",function(){updateRepulsionPower(+this.value);});
function updateRepulsionPower(x) {
	force.repulsionPower(x);
	d3.select("#repulsionPower").property("value",x);
	d3.select("#repulsionPowerValue").text(x);	
	force.resume();	
}
d3.select("#centerPullCoupling").on("input",function(){updateCenterPullCoupling(+this.value);});
function updateCenterPullCoupling(x) {
	force.centerPull().coupling = x;
	d3.select("#centerPullCoupling").property("value",x);
	d3.select("#centerPullCouplingValue").text(x);	
	force.resume();	
}			
d3.select("#saveasSVG").on("click",function(){
	var sources = crowbar.findAndParseSVGs();
	if(sources.length > 0){
		//Just download the first
		crowbar.download(sources[0]);
	}
});

var backgroundLayer = svg.append("g").attr("class","backgroundLayer");
var backgroundRect = backgroundLayer.append("rect")
	.attr("fill","white")
	.attr("width","100%").attr("height","100%").attr("x",0).attr("y",0)
	.on("mouseout",function() { removeCorners(); d3.select(this).style("fill","white");})
	.on("mousemove",function(){ polygonMouseMove(externalface);} )
	.on("mousedown",function(){ polygonMouseDown(externalface);} )
	.on("mouseup",function(){ polygonMouseUp(externalface);} );

var faceLayer = svg.append("g").attr("class","faceLayer");

var cornerLayer = svg.append("g").attr("class","cornerLayer");

var linkLayer = svg.append("g").attr("class","linkLayer");

var helpLineLayer = svg.append("g").attr("class","helpLineLayer");

var nodeLayer = svg.append("g").attr("class","nodeLayer");

var drag = d3.behavior.drag()
	.origin(function(d){return d;})
	.on("drag", dragmove)
	.on("dragstart", dragstart)
	.on("dragend", dragend);

var segmentStartCorner = {};

function updateFaceLayer()
{
	var facePolygons = faceLayer.selectAll("polygon")
		.data(faces.filter(function(f) { return !f.outer; }));
	
	facePolygons.enter().append("polygon")
		.attr("fill","white" )
		.attr("stroke","")
		.on("mouseout",function(d,i) { removeCorners(); d3.select(this).style("fill","white");})
		.on("mousemove",polygonMouseMove)
		.on("mousedown",polygonMouseDown)
		.on("mouseup",polygonMouseUp);
		
	facePolygons.exit().remove();
}

function updateCornerLayer()
{
	var cornerPolygons = cornerLayer.selectAll("polygon")
		.data(corners);
	
	cornerPolygons.enter()
		.append("polygon")
		.attr("class","corner")
		.attr("points",cornerPolygonPoints);
		
	cornerPolygons.exit().remove();
}

function updateLinkLayer()
{
	var linkLines = linkLayer.selectAll("path")
		.data(edges);
		
	linkLines.enter().append("path")
		.attr("class","link");
	
	linkLines.exit().remove();
}

function updateHelpLineLayer()
{
	var helpLines = helpLineLayer.selectAll("line")
		.data(helplines);
		
	helpLines.enter().append("line")
		.attr("class",function(d){ return d.ofclass;} );
	
	helpLines.exit().remove();
}

function updateNodeLayer()
{
	var nodeGroups = nodeLayer.selectAll("g.node")
		.data(nodes.filter(function(n){return !n.auxiliary;}));
		
	var newNodeGroups = nodeGroups.enter().append("g")
		.attr("class","node");
		
	newNodeGroups.append("circle")
	   	.attr("class","node")
	   	.attr("r","7")
	   	//.attr("r", "0.01")//"7px")
	   	.attr("fill", "blue")
	 	.call(drag);		

	newNodeGroups.append("text")
		.attr("dx",9)
		.attr("class","label")
		.style("text-anchor","start")
		.text(function(d,i) {return i;});
		
	nodeGroups.exit().remove();
}

updateFaceLayer();
updateCornerLayer();
updateLinkLayer();
updateNodeLayer();

function dragstart(d)
{
	force.dragforce().drag = true;
	force.dragforce().node = d;

	var p = d3.mouse(svg.node());
	force.dragforce().cursor = fromScreenCoor({x:p[0],y:p[1]});
	force.resume();
}
function dragmove(d)
{
	var p = d3.mouse(svg.node());
	force.dragforce().cursor = fromScreenCoor({x:p[0],y:p[1]});
	force.resume();
}
function dragend(d)
{
	force.dragforce().drag = false;
}

function cornerRadius(angle)
{
	return Math.max(0.35,Math.min(1.3,0.3/angle));
}

function polygonMouseMove(d)
{
	d3.event.preventDefault();

	if( force.dragforce().drag )
	{
		return;
	}
	var p = d3.mouse(svg.node());
	var mouse = fromScreenCoor({x:p[0],y:p[1]});	
	if( !segmentStartCorner.face || segmentStartCorner.face == d )
	{

		var mindistSq = 1000;
		var minnode = 0;
		var mincorner = 0;
		var minangle = 10;
		d.links.forEach(function(l,i){
			var thisnode = links[l.id][l.ccw?0:1];
			var distSq = mouse.copy().subVec( nodes[thisnode].pos ).normSq();
			if( !nodes[thisnode].auxiliary && distSq < mindistSq )
			{
				var prevlink = d.links[(i+d.links.length-1)%d.links.length];
				var prev = nodes[links[prevlink.id][prevlink.ccw?0:1]].pos.copy().subVec(nodes[thisnode].pos);
				var next = nodes[links[d.links[i].id][d.links[i].ccw?1:0]].pos.copy().subVec(nodes[thisnode].pos);
				var curvec = mouse.copy().subVec( nodes[thisnode].pos );
				var angle1 = next.angle(curvec),
					angle2 = next.angle(prev);
				if( angle1 <= 0.001 ) angle1 += 2*Math.PI;
				if( angle2 <= 0.001 ) angle2 += 2*Math.PI;
				if( angle1 < angle2 )
				{
					mindistSq = distSq;
					minnode = thisnode;
					mincorner = i;
					minangle = angle2;
				}
			}
		});
		
		if( mindistSq < Math.pow(cornerRadius(minangle),2) )
		{
			var prevlink = d.links[(mincorner+d.links.length-1)%d.links.length];
			var prevnode = links[prevlink.id][prevlink.ccw?0:1];
			var nextnode = links[d.links[mincorner].id][d.links[mincorner].ccw?1:0];

			if( corners.length == 0 )
			{
				corners[0] = { c: nodes[minnode], r: 0.4, prev: nodes[prevnode], next: nodes[nextnode], 
					face: d, faceindex: mincorner, nodeindex: minnode };
			} else
			{
				corners[0].c = nodes[minnode];
				corners[0].r = 0.4;
				corners[0].prev = nodes[prevnode];
				corners[0].next = nodes[nextnode];
				corners[0].face = d;
				corners[0].faceindex = mincorner;
				corners[0].nodeindex = minnode;
			}
			updateCornerLayer();
			force.resume();
		} else
		{
			removeCorners();
		}
	}
	
	if( segmentStartCorner.face )
	{
		if( helplines.length == 0 )
		{
			helplines[0] = { p1: segmentStartCorner.c.pos, p2: mouse.copy(), ofclass: "segmenthelper" };
			updateHelpLineLayer();
		} else
		{
			helplines[0].p1 = segmentStartCorner.c.pos;
			helplines[0].p2 = mouse.copy();
			updateHelpLineLayer();
		}
		force.resume();
	} else 
	{
		removeHelpLines();
	}
	

}
/*
function polygonClick(d,i)
{
	if( corners.length == 1 )
	{
		insertEdge(corners[0]);
	}
	removeHelpLines();
}
*/


function polygonMouseDown(d)
{
	d3.event.preventDefault();
	if( corners.length == 1 )
	{
		segmentStartCorner.c = corners[0].c;
		segmentStartCorner.face = corners[0].face;		
		segmentStartCorner.faceindex = corners[0].faceindex;
		segmentStartCorner.nodeindex = corners[0].nodeindex;		
	} else
	{
		segmentStartCorner = {};
	}
}

function polygonMouseUp(d)
{
	if( corners.length == 1 && segmentStartCorner.face && segmentStartCorner.face == corners[0].face )
	{
		if( segmentStartCorner.faceindex != corners[0].faceindex)
		{
			splitFace([segmentStartCorner,corners[0]]);	
			/*var thisface = corners[0].face.links.map(function(l){
				return (l.ccw? nodes[links[l.id][0]].pos : nodes[links[l.id][1]].pos );
			});
			if( CMap.isProperDiagonal(thisface, [segmentStartCorner.faceindex, corners[0].faceindex]) )
			{
				splitFace([segmentStartCorner,corners[0]]);	
			}*/
		} else
		{
			insertEdge(corners[0]);
		}
	}
	segmentStartCorner = {};
	removeHelpLines();
}

function insertEdge(corner)
{
	var nextvec = corner.next.pos.copy().subVec(corner.c.pos);
	var prevvec = corner.prev.pos.copy().subVec(corner.c.pos);
	var angle = nextvec.angle(prevvec);
	if( angle <= 0.001 ) angle += 2*Math.PI;
	
	var newcoor = nextvec.rotate(0.5*angle).mult(0.6).addVec(corner.c.pos);
	nodes.push({pos: newcoor});
	links.push([corner.nodeindex,nodes.length-1]);
	edges.push([links.length-1]);
	corner.face.links.splice(corner.faceindex,0,{id:links.length-1,ccw:true},{id:links.length-1,ccw:false});
	
	while( CMap.faceIsNonSimple(corner.face,links,nodes) )
	{
		newcoor.subVec(corner.c.pos).mult(0.6).addVec(corner.c.pos);
	}
	
	updateFaceLayer()
	updateLinkLayer();
	updateNodeLayer();
	
	removeCorners();
	force.resume();
}

function splitFace(corners)
{
	var thisface = corners[0].face.links.map(function(l){
		return (l.ccw? nodes[links[l.id][0]].pos : nodes[links[l.id][1]].pos );
	});
	
	var c = ( corners[0].faceindex < corners[1].faceindex ? 
		[ corners[0], corners[1] ] : [ corners[1], corners[0] ] );
	
	var path = [];
	if( !c[0].face.outer )
	{
		if( thisface.length == 3 )
		{
			path = [thisface[0].copy().addVec(thisface[1]).addVec(thisface[2]).divide(3)];
		} else if( !c[0].face.outer )
		{
			path = CMap.findPathInPolygon(thisface,[c[0].faceindex,c[1].faceindex]);
		} 
	} else 
	{
		if( !CMap.isProperDiagonal(thisface,[c[0].faceindex,c[1].faceindex]) )
		{
			// Construct a bounding box
			var boundingbox = {min: new Vec2(-1,-1), max: new Vec2(1,1)};
			thisface.forEach(function(p){
				if( p.x < boundingbox.min.x ) boundingbox.min.x = p.x;
				if( p.y < boundingbox.min.y ) boundingbox.min.y = p.y;
				if( p.x > boundingbox.max.x ) boundingbox.max.x = p.x;
				if( p.y > boundingbox.max.y ) boundingbox.max.y = p.y;
			});
			var center = boundingbox.max.copy().addVec(boundingbox.min).mult(0.5);
			boundingbox.min.subVec(center).mult(1.4).addVec(center);
			boundingbox.max.subVec(center).mult(1.4).addVec(center);
			var box = [ boundingbox.min, 
						new Vec2(boundingbox.max.x, boundingbox.min.y),
						boundingbox.max,
						new Vec2(boundingbox.min.x, boundingbox.max.y) ];
			
			// Choose the vertex furthest away from the corners c
			var distance = 0;
			var index = 0;
			thisface.forEach(function(p,i){
				var d = p.copy().subVec(c[0].c.pos).norm() + p.copy().subVec(c[1].c.pos).norm();
				if( d > distance )
				{
					distance = d;
					index = i;
				}
			});
			
			var next = thisface[(index+1)%thisface.length];
			var prev = thisface[(index+thisface.length-1)%thisface.length];
			var normal = thisface[index].copy().subVec(prev);
			if( next != prev )
			{
				normal = next.copy().subVec(thisface[index]).getBisector(prev.copy().subVec(thisface[index]));
			}
			// Rearrange box to line up with the normal
			if( normal.x <= 0 && normal.y > 0 )
			{
				box.unshift(box.pop());
			} else if( normal.x > 0 )
			{
				box.push(box.shift());
				if( normal.y > 0 )
				{
					box.push(box.shift());
				}
			}
			thisface.splice(index,0,thisface[index],
				box[0], box[0].copy().addVec(box[1]).mult(0.5),
				box[1], box[1].copy().addVec(box[2]).mult(0.5),
				box[2], box[2].copy().addVec(box[3]).mult(0.5),
				box[3], box[3].copy().addVec(box[0]).mult(0.5),
				box[0]);
			path = CMap.findPathInPolygon(thisface,
				[c[0].faceindex + (c[0].faceindex > index ? 10 : 0)
				,c[1].faceindex + (c[1].faceindex > index ? 10 : 0)]);
		}
	}

	var firstNodeId = nodes.length;
	path.forEach(function(p){ 
		nodes.push({pos: p, auxiliary: true});
	});
	
	edges.push([]);
	var firstLinkId = links.length;
	for(var i=0;i<=path.length;i++)
	{
		links.push([ i==0 ? c[0].nodeindex : firstNodeId+i-1,
					 i==path.length ? c[1].nodeindex : firstNodeId+i ]);
		edges[edges.length-1].push(links.length-1);
	}
	faces.push({links: 
		c[0].face.links.splice(c[0].faceindex,c[1].faceindex-c[0].faceindex),
		outer: false,
		color: c[0].face.color});
	for(var i=path.length;i>=0;i--)
	{
		faces[faces.length-1].links.push({id: firstLinkId + i, ccw: false});
		c[0].face.links.splice(c[0].faceindex,0,{id: firstLinkId + i, ccw: true});
	}
	
	if( c[0].face.outer )
	{
		var angle = CMap.faceAngleSum(c[0].face,links,nodes);
		if( Math.abs(angle-(c[0].face.links.length-2)*Math.PI) < 0.1 )
		{
			// the previously outer face is not the outer face anymore
			c[0].face.outer = false;
			faces[faces.length-1].outer = true;
			externalface = faces[faces.length-1];
		}
	}
		
	updateFaceLayer();
	updateLinkLayer();
	force.resume();
}

function removeHelpLines()
{
	if( helplines.length > 0 )
	{
		while( helplines.length > 0 )
		{
			helplines.pop();
		}
		updateHelpLineLayer();
	}
}

function removeCorners()
{
	//if( removeCorners.length > 0 )
	//{
		while(corners.length > 0) {
			corners.pop();
		}
		updateCornerLayer();
	//}
}

function cornerPolygonPoints(corner)
{
	var coor = [];
	coor.push(corner.c.pos);
	var radial=corner.next.pos.copy().subVec(corner.c.pos).normalize();
	var angle = radial.angle(corner.prev.pos.copy().subVec(corner.c.pos));
	if( angle <= 0.0001 ) angle += 2*Math.PI;
	
	radial.mult(cornerRadius(angle));
	var subdiv = Math.ceil(angle/0.2);
	for( var i=0;i<=subdiv;i++)
	{
		coor.push(radial.copy().rotate(i*angle/subdiv).addVec(corner.c.pos));
	}
	return coor.map(function(p) {
		var scr = toScreenCoor(p);
		return [scr.x,scr.y].join(","); }).join(" ");
}

function roundCornerPath(path,radius)
{
	function coorstr(p) { 
		var scr = toScreenCoor(p);
		return scr.x + " " + scr.y;
	}
	var p = "M " + coorstr(path[0]);
	
	for(var i=1;i<path.length-1;i++)
	{
		var prev = path[i-1].copy().subVec(path[i]);
		var next = path[i+1].copy().subVec(path[i]);
		var thisradius = Math.min(radius,Math.min(prev.norm()/2,next.norm()/2));
		prev.normalize().mult(thisradius).addVec(path[i]);
		next.normalize().mult(thisradius).addVec(path[i]);
		p += " L " + coorstr(prev) + " Q " + coorstr(path[i]) + " " + coorstr(next);
	}
	p += " L " + coorstr(path[path.length-1]);
	return p;
}

function updateMap()
{
	nodeLayer.selectAll("g.node").attr("transform", function(d){
		return "translate(" + [toScreenCoor(d.pos).x,toScreenCoor(d.pos).y] + ")";
   	});

	linkLayer.selectAll("path")
		.attr("d", function(edg) {
			var coor = edg.map(function(l) {
				return nodes[links[l][0]].pos;
			});
			coor.push(nodes[links[edg[edg.length-1]][1]].pos);
			return roundCornerPath(coor, 0.5);
		});
	
	cornerLayer.selectAll("polygon")
		.attr("points",cornerPolygonPoints);
	
	helpLineLayer.selectAll("line")
		.attr("x1", function(d) { return toScreenCoor(d.p1).x; })
		.attr("y1", function(d) { return toScreenCoor(d.p1).y; })
		.attr("x2", function(d) { return toScreenCoor(d.p2).x; })
		.attr("y2", function(d) { return toScreenCoor(d.p2).y; });

	faceLayer.selectAll("polygon")
		.attr("points",function(d) {
		return d.links.map(function(p) { 
			var coor = toScreenCoor(nodes[links[p.id][(p.ccw?0:1)]].pos);
			return [coor.x,coor.y].join(","); 
		}).join(" ");
	});

}

updateSpringCoupling(1);
updateSpringLength(1);
updateRepulsionPower(1);


</script>
</body>
</html>
