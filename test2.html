<html>
<head>
<style>
.link {
	stroke: #999;
}
.forcevec {
	stroke: red;
}
svg {
	border: 1px solid black;
}
svg polygon.corner {
	fill: #ddaa40;
	pointer-events: none;
}
svg text.label {
	pointer-events: none;
	font-family: Verdana;
	font-size: 14;
}
svg line.link {
	stroke-width: 2;
	stroke: #aaaaaa;
}
svg line.segmenthelper {
	pointer-events: none;
	stroke-width: 2;
	stroke: #aaaaaa;
	stroke-dasharray: 5,5;
}
svg circle.node {
	cursor:move;
}
#controls label {
	display: inline-block;
	width: 120px;
	text-align: right;
}
</style>
</head>
<body>
<div id="pmap">
</div>
<div id="controls">
<p>
	<label for="springCoupling">Spring coupling</label>
	<input type="range" min="0.2" max="8" id="springCoupling" value="1" step="0.2" />
	<span id="springCouplingValue">1</span>
</p>
<p>
	<label for="springLength">Spring length</label>
	<input type="range" min="0.4" max="3" id="springLength" value="1" step="0.2" />
	<span id="springLengthValue">1</span>
</p>
<p>
	<label for="repulsionPower">Repulsion power</label>
	<input type="range" min="0.4" max="2" id="repulsionPower" value="1" step="0.1" />
	<span id="repulsionPowerValue">1</span>
</p>
<p>
	<input id="savePNG" type="button" value="Save as PNG" />
</p>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.1/d3.min.js"></script>
<script src="force.js"></script>
<script src="external/rgbcolor.js"></script>
<script src="external/canvg.js"></script>
<script src="external/svgenie.js"></script>
<script>


var nodes = [{x: 1., y: 0.}, {x: 0.309017, y: 0.951057}, {x: -0.809017, y: 0.587785}, 
			 {x: -0.809017, y: -0.587785}, {x: 0.309017, y: -0.951057}, {x: 0.4, y: 0.2}, 
			 {x: 2., y: 0.}, {x: 2., y: 3.}, {x: 1., y: 1.}, {x: 1.2, y: 1.}
			].map(function(p){return {pos: new Vec2(p.x,p.y)};});
		 
var links = [ [0,1], [1,2], [2,3], [3,4], [4,0], 
			  [0,5], [4,6], [6,0], [1,7], [7,2], 
			  [6,7], [0,8], [8,9], [9,0] ];
var faces = [{links: [{id:0,ccw:true}, {id:1,ccw:true}, {id:2,ccw:true}, {id:3,ccw:true}, 
					  {id:4,ccw:true}, {id:5,ccw:true},{id:5,ccw:false}], 
			  outer: false,
			  color: "#f0f0ff"}, 
			 {links: [{id:4,ccw:false},{id:6,ccw:true},{id:7,ccw:true}], 
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:8,ccw:true},{id:9,ccw:true},{id:1,ccw:false}],
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:7,ccw:false},{id:10,ccw:true},{id:8,ccw:false},{id:0,ccw:false},
			 		  {id:11,ccw:true},{id:12,ccw:true},{id:13,ccw:true}], 
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:13,ccw:false},{id:12,ccw:false},{id:11,ccw:false}],
			  outer: false,
			  color: "#f0f0ff"},
			 {links: [{id:9,ccw:false},{id:10,ccw:false},{id:6,ccw:false},
			 		  {id:3,ccw:false},{id:2,ccw:false}],
			  outer: true,
			  color: "#f0f0ff"}];

var helplines = [];
var corners = [];

var scale = 60;
var offset = {x: 500, y: 250};
function toScreenCoor(d)
{
	return new Vec2(scale*d.x + offset.x,-scale*d.y + offset.y);
}
function fromScreenCoor(c)
{
	return new Vec2((c.x-offset.x)/scale,(-c.y+offset.y)/scale);
}

var svg = d3.select("#pmap").append("svg")
	.attr("id","pmapsvg")
	.attr("width",1000).attr("height",500);


var force = CMap.force().nodes(nodes)
	.faces(faces)
	.links(links)
	.clip({use: false, minX: fromScreenCoor({x:0,y:svg.attr("height")}).x,
					  minY: fromScreenCoor({x:0,y:svg.attr("height")}).y,
					  maxX: fromScreenCoor({x:svg.attr("width"),y:0}).x,
					  maxY: fromScreenCoor({x:svg.attr("width"),y:0}).y})
	.centerPull({pull: true, center: new Vec2(0,0), coupling: 0.4})
	.on("tick",updateMap)
	.on("end",updateMap);

d3.select("#springCoupling").on("input",function(){updateSpringCoupling(+this.value);});
function updateSpringCoupling(x) {
	force.springCoupling(x);
	d3.select("#springCoupling").property("value",x);
	d3.select("#springCouplingValue").text(x);
	force.resume();	
}	
d3.select("#springLength").on("input",function(){updateSpringLength(+this.value);});
function updateSpringLength(x) {
	force.springLength(x);
	d3.select("#springLength").property("value",x);
	d3.select("#springLengthValue").text(x);
	force.resume();		
}	
d3.select("#repulsionPower").on("input",function(){updateRepulsionPower(+this.value);});
function updateRepulsionPower(x) {
	force.repulsionPower(x);
	d3.select("#repulsionPower").property("value",x);
	d3.select("#repulsionPowerValue").text(x);	
	force.resume();	
}		


var faceLayer = svg.append("g").attr("class","faceLayer");

var cornerLayer = svg.append("g").attr("class","cornerLayer");

var linkLayer = svg.append("g").attr("class","linkLayer");

var helpLineLayer = svg.append("g").attr("class","helpLineLayer");

var nodeLayer = svg.append("g").attr("class","nodeLayer");

var drag = d3.behavior.drag()
	.origin(function(d){return d;})
	.on("drag", dragmove)
	.on("dragstart", dragstart)
	.on("dragend", dragend);

var segmentStartCorner = {};

function updateFaceLayer()
{
	var facePolygons = faceLayer.selectAll("polygon")
		.data(faces.filter(function(f) { return !f.outer; }));
	
	facePolygons.enter().append("polygon")
		.attr("fill",function(d){return d.color;} )
		.attr("fill-opacity",0)
		.attr("stroke","")
		.on("mouseover",function(d,i) { if(!force.dragforce().drag) {d3.select(this).style("fill-opacity",1);}})
		.on("mouseout",function(d,i) { removeHelpLines(); removeCorners(); segmentStartCorner = {}; d3.select(this).style("fill-opacity",0);})
		.on("mousemove",polygonMouseMove)
		.on("mousedown",polygonMouseDown)
		.on("mouseup",polygonMouseUp);
		
	facePolygons.exit().remove();
}

function updateCornerLayer()
{
	var cornerPolygons = cornerLayer.selectAll("polygon")
		.data(corners);
	
	cornerPolygons.enter()
		.append("polygon")
		.attr("class","corner")
		.attr("points",cornerPolygonPoints);
		
	cornerPolygons.exit().remove();
}

function updateLinkLayer()
{
	var linkLines = linkLayer.selectAll("line")
		.data(links);
		
	linkLines.enter().append("line")
		.attr("class","link");
	
	linkLines.exit().remove();
}

function updateHelpLineLayer()
{
	var helpLines = helpLineLayer.selectAll("line")
		.data(helplines);
		
	helpLines.enter().append("line")
		.attr("class",function(d){ return d.ofclass;} );
	
	helpLines.exit().remove();
}

function updateNodeLayer()
{
	var nodeGroups = nodeLayer.selectAll("g.node")
		.data(nodes);
		
	var newNodeGroups = nodeGroups.enter().append("g")
		.attr("class","node");
		
	newNodeGroups.append("circle")
	   	.attr("class","node")
	   	.attr("r", "7px")
	   	.attr("fill", "blue")
	 	.call(drag);		

	newNodeGroups.append("text")
		.attr("dx",9)
		.attr("class","label")
		.style("text-anchor","start")
		.text(function(d,i) {return i;});
		
	nodeGroups.exit().remove();
}

updateFaceLayer();
updateCornerLayer();
updateLinkLayer();
updateNodeLayer();

function dragstart(d)
{
	force.dragforce().drag = true;
	force.dragforce().node = d;

	var p = d3.mouse(svg.node());
	force.dragforce().cursor = fromScreenCoor({x:p[0],y:p[1]});
	force.resume();
}
function dragmove(d)
{
	var p = d3.mouse(svg.node());
	force.dragforce().cursor = fromScreenCoor({x:p[0],y:p[1]});
	force.resume();
}
function dragend(d)
{
	force.dragforce().drag = false;
}

function polygonMouseMove(d,i)
{
	d3.event.preventDefault();

	if( force.dragforce().drag )
	{
		return;
	}
	
	var p = d3.mouse(svg.node());
	var mouse = fromScreenCoor({x:p[0],y:p[1]});
	var mindistSq = 1000;
	var minnode = 0;
	var mincorner = 0;
	d.links.forEach(function(l,i){
		var thisnode = links[l.id][l.ccw?0:1];
		var distSq = mouse.copy().subVec( nodes[thisnode].pos ).normSq();
		if( distSq < mindistSq )
		{
			var prevlink = d.links[(i+d.links.length-1)%d.links.length];
			var prev = nodes[links[prevlink.id][prevlink.ccw?0:1]].pos.copy().subVec(nodes[thisnode].pos);
			var next = nodes[links[d.links[i].id][d.links[i].ccw?1:0]].pos.copy().subVec(nodes[thisnode].pos);
			var curvec = mouse.copy().subVec( nodes[thisnode].pos );
			var angle1 = next.angle(curvec),
				angle2 = next.angle(prev);
			if( angle1 <= 0.001 ) angle1 += 2*Math.PI;
			if( angle2 <= 0.001 ) angle2 += 2*Math.PI;
			if( angle1 < angle2 )
			{
				mindistSq = distSq;
				minnode = thisnode;
				mincorner = i;
			}
		}
	});
	
	if( segmentStartCorner.face && segmentStartCorner.face == d )
	{
		if( helplines.length == 0 )
		{
			helplines[0] = { p1: segmentStartCorner.c.pos, p2: mouse.copy(), ofclass: "segmenthelper" };
			updateHelpLineLayer();
		} else
		{
			helplines[0].p1 = segmentStartCorner.c.pos;
			helplines[0].p2 = mouse.copy();
			updateHelpLineLayer();
		}
		force.resume();
	} else 
	{
		removeHelpLines();
	}
	
	if( mindistSq < 0.4*0.4 )
	{
		var prevlink = d.links[(mincorner+d.links.length-1)%d.links.length];
		var prevnode = links[prevlink.id][prevlink.ccw?0:1];
		var nextnode = links[d.links[mincorner].id][d.links[mincorner].ccw?1:0];

		if( corners.length == 0 )
		{
			corners[0] = { c: nodes[minnode], r: 0.4, prev: nodes[prevnode], next: nodes[nextnode], 
				face: d, faceindex: mincorner, nodeindex: minnode };
		} else
		{
			corners[0].c = nodes[minnode];
			corners[0].r = 0.4;
			corners[0].prev = nodes[prevnode];
			corners[0].next = nodes[nextnode];
			corners[0].face = d;
			corners[0].faceindex = mincorner;
			corners[0].nodeindex = minnode;
		}
		updateCornerLayer();
		force.resume();
	} else
	{
		removeCorners();
	}
}
/*
function polygonClick(d,i)
{
	if( corners.length == 1 )
	{
		insertEdge(corners[0]);
	}
	removeHelpLines();
}
*/


function polygonMouseDown(d,i)
{
	d3.event.preventDefault();
	if( corners.length == 1 )
	{
		segmentStartCorner.c = corners[0].c;
		segmentStartCorner.face = corners[0].face;		
		segmentStartCorner.faceindex = corners[0].faceindex;
		segmentStartCorner.nodeindex = corners[0].nodeindex;		
	} else
	{
		segmentStartCorner = {};
	}
}

function polygonMouseUp(d,i)
{
	if( corners.length == 1 && segmentStartCorner.face && segmentStartCorner.face == corners[0].face )
	{
		if( segmentStartCorner.nodeindex != corners[0].nodeindex)
		{
			splitFace([segmentStartCorner,corners[0]]);	
		} else
		{
			insertEdge(corners[0]);
		}
	}
	segmentStartCorner = {};
	removeHelpLines();
}

function insertEdge(corner)
{
	var nextvec = corner.next.pos.copy().subVec(corner.c.pos);
	var prevvec = corner.prev.pos.copy().subVec(corner.c.pos);
	var angle = nextvec.angle(prevvec);
	if( angle <= 0.001 ) angle += 2*Math.PI;
	
	var newcoor = nextvec.rotate(0.5*angle).mult(0.2).addVec(corner.c.pos);
	nodes.push({pos: newcoor});
	links.push([corner.nodeindex,nodes.length-1]);
	corner.face.links.splice(corner.faceindex,0,{id:links.length-1,ccw:true},{id:links.length-1,ccw:false});
	updateFaceLayer()
	updateLinkLayer();
	updateNodeLayer();
	
	removeCorners();
	force.resume();
}

function splitFace(corners)
{
	var c = ( corners[0].faceindex < corners[1].faceindex ? [ corners[0], corners[1] ] : [ corners[1], corners[0] ] );

	links.push([c[0].nodeindex,c[1].nodeindex]);
	faces.push({links: 
		c[0].face.links.splice(c[0].faceindex,c[1].faceindex-c[0].faceindex,
			{id: links.length-1, ccw: true}),
		outer: false,
		color: c[0].face.color});
	faces[faces.length-1].links.push({id: links.length-1, ccw: false});
	updateFaceLayer();
	updateLinkLayer();
	force.resume();
}

function removeHelpLines()
{
	if( helplines.length > 0 )
	{
		while( helplines.length > 0 )
		{
			helplines.pop();
		}
		updateHelpLineLayer();
	}
}

function removeCorners()
{
	//if( removeCorners.length > 0 )
	//{
		while(corners.length > 0) {
			corners.pop();
		}
		updateCornerLayer();
	//}
}

function cornerPolygonPoints(corner)
{
	var coor = [];
	coor.push(corner.c.pos);
	var radial=corner.next.pos.copy().subVec(corner.c.pos).normalize().mult(corner.r);
	var angle = radial.angle(corner.prev.pos.copy().subVec(corner.c.pos));
	if( angle <= 0.0001 ) angle += 2*Math.PI;
	var subdiv = Math.ceil(angle/0.2);
	for( var i=0;i<=subdiv;i++)
	{
		coor.push(radial.copy().rotate(i*angle/subdiv).addVec(corner.c.pos));
	}
	return coor.map(function(p) {
		var scr = toScreenCoor(p);
		return [scr.x,scr.y].join(","); }).join(" ");
}

function updateMap()
{
	nodeLayer.selectAll("g.node").attr("transform", function(d){
		return "translate(" + [toScreenCoor(d.pos).x,toScreenCoor(d.pos).y] + ")";
   	});


	linkLayer.selectAll("line")
		.attr("x1", function(d) { return toScreenCoor(nodes[d[0]].pos).x; })
		.attr("y1", function(d) { return toScreenCoor(nodes[d[0]].pos).y; })
		.attr("x2", function(d) { return toScreenCoor(nodes[d[1]].pos).x; })
		.attr("y2", function(d) { return toScreenCoor(nodes[d[1]].pos).y; });
	
	cornerLayer.selectAll("polygon")
		.attr("points",cornerPolygonPoints);
	
	helpLineLayer.selectAll("line")
		.attr("x1", function(d) { return toScreenCoor(d.p1).x; })
		.attr("y1", function(d) { return toScreenCoor(d.p1).y; })
		.attr("x2", function(d) { return toScreenCoor(d.p2).x; })
		.attr("y2", function(d) { return toScreenCoor(d.p2).y; });

	faceLayer.selectAll("polygon")
		.attr("points",function(d) {
		return d.links.map(function(p) { 
			var coor = toScreenCoor(nodes[links[p.id][(p.ccw?0:1)]].pos);
			return [coor.x,coor.y].join(","); 
		}).join(" ");
	});

}

updateSpringCoupling(1);
updateSpringLength(1);
updateRepulsionPower(1);

document.getElementById("savePNG").onclick = function() {
	svgenie.save( "pmapsvg" , { name: "test.png" });
};

</script>
</body>
</html>
