<html>
<head>
<link rel="stylesheet" type="text/css" href="../thirdparty/css-toggle-switch/toggle-switch.css">
<link href="../thirdparty/mcColorPicker/mcColorPicker.css" rel="stylesheet" type="text/css" />
<script src="../thirdparty/mcColorPicker/mcColorPicker.js" type="text/javascript"></script>
<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	padding: 0;
	font-family: "Helvetica Neue", Helvetica, sans-serif;
	font-size:6;
}
#pmap {
	width: 100%;
	height: 100%;
	top: 0;
	left: 0;
}
#arrowend, #arrowstart {
	fill: #404040;
}
svg path.edge {
	stroke: #404040;
	stroke-width: 1;
	stroke-linecap: round;
	fill: none;
}
svg path.edge.selected {
	stroke: #902020 !important;
	stroke-width: 1.4 !important;
	fill: none;
}
svg path.edge.dualedge {
	stroke: #20d020;
}
svg path.face {
	stroke: none;
	fill: #ffffdd;
}
svg path.face.selected {
	stroke: red !important;
	stroke-width: 2 !important;
}
svg .cornerLayer path {
	stroke: none;
	fill: #ff2222;
	pointer-events: none;
}
svg text.label {
	pointer-events: none;
}
svg circle.node {
	fill: #404040;
	stroke: none;
}
svg circle.node.dualnode {
	fill: #20d020;
}
svg circle.node.intersection {
	fill: none;
	pointer-events: all;
}
svg circle.node.selected {
	stroke: red !important;
	stroke-width: 0.6 !important;
}
svg path.edge.contract {
	stroke: #cccccc;
}
div#title {
	z-index:101; 
	position:absolute;
	top:0px;
	left:20px;
	pointer-events: none;
}
#title h1 {
	color: #aaaaaa;
	font-weight: bold;
	font-family: "Helvetica", sans-serif;
	font-size: 40px;
	text-rendering: optimizeLegibility;
	margin-bottom:0px;
}
.panelcontainer {
	z-index:101;
	position:absolute;
	top:10px;
	right:10px;
	width:220px;
	background-color: #444444;
	margin: 0;
	padding: 0;
}
.panel {
	display: block;
	width: 100%;
	margin: 0;
	padding: 0;
	color: #d2d2d2;
}
.panel h2 {
	display: block;
	width: 100%;
	padding-left: 8px;
	padding-top: 3px;
	padding-bottom: 3px;
	padding-right: 0;
	margin: 0;
	text-transform: uppercase;
	font-size: 15px;
	color: #bcbcbc;
	background-color: #242424;
	box-sizing: border-box;
	border-top: 1px solid #bcbcbc;
	border-bottom: 1px solid #bcbcbc;
	cursor: pointer;
}
.panel h2:before {
	content: "\25BE";
	padding-right: 6px;
}
.panel.closed h2:before {
	content: "\25B8";
	padding-right: 6px;
}
.panel.closed p {
	display: none;
}
.panel p {
	display:block;
	padding-left: 8px;
	padding-right: 8px;
//  width:100%;
	font-size: 14px;
}
/*.panel p label {
	display: block;
	width: 100%;
}*/
.panel p input.slider {
	width:190px;
	margin-left: 10px;
	margin-right: 10px;
}
.editorhints {
	z-index:101;
	pointer-events: none;
	position:absolute;
	top:80px;
	left:15px;
	font-size: 14px;
}
dl.controls dt {
	float: left;
	clear: left;
	width: 120px;
	text-align: right;
	font-family: courier;
}
dl.controls dt:after {
	content: ":";
}
dl.controls dd {
	color: black;
	margin: 0 40px 0 130px;
	padding: 0 0 0.4em 0;
	font-weight: bold;
	font-family: sans-serif;
	width:260px;
}

.colorpicklabel {
	display: inline-block;
	width: 70px;
}
div#colorpicker {
	left: -154px;
}
input.color {
	width: 70px;
}

</style>

</head>
<body>
	
<div id="title">
	<h1>Planarmap.js editor</h1>
</div>
<div class="editorhints">
	<dl class="controls">
		<dt>Drag</dt><dd>Pan or drag vertex</dd>
		<dt>Mousewheel</dt><dd>Zoom</dd>
		<dt>Click</dt><dd>Select</dd>
		<dt>Shift-Click</dt><dd>Select more</dd>
		<dt>Backspace</dt><dd>Undo</dd>
		<dt>Delete</dt><dd>Delete edge</dd>
		<dt>E</dt><dd>Create edge
			<br /><img src="./images/newedge1.png" width=100px>
			<br /><img src="./images/newedge2.png" width=110px>
		</dd>
		<dt>S</dt><dd>Split vertex or edge
			<br /><img src="./images/splitedge.png" width=120px>
			<br /><img src="./images/splitvertex.png" width=110px>
		</dd>
		<dt>C</dt><dd>Contract edge
			<br /><img src="./images/contractedge.png" width=110px>
		</dd>
		<dt>G</dt><dd>Glue edges
			<br /><img src="./images/glueedges.png" width=110px>
		</dd>
		<dt>2-9</dt><dd>Insert face of that degree
			<br /><img src="./images/insertface.png" width=110px>
		</dd>
		<dt>M</dt><dd>Toggle marker
			<br /><img src="./images/addmarker.png" width=110px>
		</dd>
		<dt>F/R</dt><dd>Fix/release node position
		</dd>
		<dt>D</dt><dd>Draw dual map
		</dd>
	</dl>
</div>

<div class="panelcontainer"></div>
<div id="pmap"></div>


<script charset="utf-8" src="../thirdparty/d3/d3.js"></script>
<script src="../src/geometry.js"></script>
<script src="../src/layout.js"></script>
<script src="../src/force.js"></script>
<script src="../src/planarmap.js"></script>
<script src="../src/view.js"></script>
<script src="../src/algorithms.js"></script>
<script src="../src/controlpanel.js"></script>
<script src="./data/planarmapexamples.js"></script>
<script src="../thirdparty/crowbar/svg-crowbar.js"></script>

<script>

var svg = d3.select("#pmap").append("svg")
	.attr("id","pmapsvg")
	.attr("width","100%")
	.attr("height","100%")
	.attr("viewBox","-160 -100 320 200")
	.attr("preserveAspectRatio", "xMidYMid meet")	
	
var planarmap = CMap.PlanarMap();
var layoutupdater = CMap.LayoutUpdater()
	.registerAll(planarmap);

planarmap.singleEdgeMap();	
	
var view = CMap.View(planarmap,svg).zoom();
view.nodeText(function(node){
	return node.attr.id ;
}).updateLayers();

var force = CMap.force(planarmap)
	.centerPull({pull: true, center: new Vec2(0,0), coupling: 0.1})
	.stretchForce(true)
	.on("tick",function(){ 
		layoutupdater.attemptStretch(planarmap);
		view.updatePositions();
	})
	.resume();
layoutupdater.onChange(function(){ force.resume() });

var control = CMap.ControlPanel(".panelcontainer");

var filepanel = control.addPanel("file","File",false,function(){});
var fileload = filepanel.addEmpty();
fileload.append("input").attr("type","file")
	.attr("id","fileinput")
	.attr("accept",".json,.svg")
	.style("display","none")
	.on("change",function(){
		var file = this.files[0];
		var reader = new FileReader();
		reader.onload = function(e) {
			var json;
			try{
				// first try parsing as pure JSON
				json = JSON.parse(reader.result);
			}catch(e){
				// otherwise try to find CDATA-field in file and parse that
				var cdata = reader.result.split('<jsondata><'+'![CDATA[');
				if( cdata.length < 2 )
					return;
				cdata = cdata[1].split(']]>')[0];
				try{
					json = JSON.parse(cdata);
				}catch(e2){
					return;	
				}
			}
			planarmap.fromJSON(json);
			view.updateLayers(true);
			view.updatePositions();
			force.resume();
		}
		reader.readAsText(file);

		this.value = "";
	});

	
fileload.append("input").attr("type","button")
	.attr("value","Load JSON or SVG...")
	.on("click",function(){
		document.getElementById("fileinput").click();
	});
	
	
(function(){
	var exampleselect = filepanel.addEmpty().append("select")
		.on("change",function(){
			if( this.value != "" )
			{
				// make copy of example data
				addStateToUndoHistory();
				var json = JSON.parse(JSON.stringify(exampledata[this.value]));
				planarmap.fromJSON(json);
				view.updateLayers(true);
				view.updatePositions();
			}
			this.value="";
			this.blur();
		});
	exampleselect
		.append("option")
		.attr("class","selectheader")
		.text("---- Load example ----")
		.attr("value","");
		
	var examples = [
		["Triangulation","triangulation"],
		["Quadrangulation","quadrangulation"],
		["Plane tree","tree"],
		["Square grid","squaregrid"],
		["Goldner-Harary","goldner-harary"],
		["Dodecahedron","dodecahedron"]
	];
	
	exampleselect.selectAll("option.selectoption")
			.data(examples)
			.enter().append("option")
			.attr("class","selectoption")
			.attr("value",function(d){ return d[1];})
			.text(function(d){return d[0];});		
})();
	
function downloadfile(filename, text) {
    var pom = document.createElement('a');
    pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    pom.setAttribute('download', filename);

    if (document.createEvent) {
        var event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        pom.dispatchEvent(event);
    }
    else {
        pom.click();
    }
}
var filedownload = filepanel.addEmpty();
filedownload.append("input").attr("type","button")
	.attr("value","Download JSON")
	.on("click",function(){
		view.clearSelection();
		downloadfile("map.json",JSON.stringify(planarmap));

	});
var svgdownload = filepanel.addEmpty()
	.append("input").attr("type","button")
	.attr("value","Download SVG")
	.on("click",function(){
		view.clearSelection();
		var content = d3.select("#pmap").html();
		var div = d3.select("body").append("div")
			.style("display","none")
			.html(content);
		div.select("#zoomgroup").attr("transform",null);
		div.select(".backgroundLayer").remove();
		div.select(".helpLineLayer").remove();
		div.select(".cornerLayer").remove();
		
		// Extract bounding box from original svg.
		// For some reason one cannot do so for an SVG with display:none.
		var rect = d3.select("#pmap .edgelayer").node().getBBox();
		var margin = 5;
		rect.x -= margin;
		rect.y -= margin;
		rect.width += 2*margin;
		rect.height += 2*margin;
		
		if( typeof overrideBBox != 'undefined' ) rect = overrideBBox;
		
		div.select("svg").attr("id","svgcopy")
			.attr("viewBox",rect.x + " " + rect.y + " " + rect.width + " " + rect.height)
			.append("jsondata").text("<!"+"[CDATA[" + 
				JSON.stringify(planarmap) + "]]>");
		
		crowbar.downloadById("svgcopy",
			["stroke","stroke-width","fill"] );	
		div.remove();

	});
filepanel.addEmpty()
	.append("input").attr("type","button")
	.attr("value","Clear (single edge map)")
	.on("click",function(){
		addStateToUndoHistory();
		planarmap.singleEdgeMap();
		view.updateLayers();
		view.updatePositions();
	});

control.addPanel("forcelayout","Force layout",
	true, function(){ force.resume(); })
	.addToggle("Force","Off","On",force.enabled)
	.addSlider("Spring coupling","springcoupling",
		force.springCoupling, 0.2, 10, 0.2)
	.addSlider("Spring length","springlength",
		force.springLength, 0.2, 2.5, 0.1)
	.addSlider("Repulsion power","repulsionpower",
		force.repulsionPower, 0.3, 2, 0.1)
	.addSlider("Centering force","centerpullcoupling",
		force.centerPullCoupling, 0., 5, 0.1)
	.addSlider("Initial stepsize","initialstepsize",
		force.initialStepsize, 0.0005, 0.03, 0.0005)
	.addSlider("Lower threshold","lowerthreshold",
		force.lowerThreshold, 0.0, 0.2, 0.005)	
		;	

function getAllClasses(map) {
	var classes = {};
	function addclass(f){
		for( thisclass in f.class )
		{
			classes[thisclass] = classes[thisclass] || f.class[thisclass];
		}
	}
	map.faces().forEach(addclass);
	map.edges().forEach(addclass);
	map.nodes().forEach(addclass);

	return Object.keys(classes);
}

var classes = getAllClasses(planarmap);
var selectpanel = control.addPanel("select","Selection",true);

selectpanel.addEmpty()
	.append("input").attr("type","button")
	.attr("value","Select none")
	.on("click",function(){
		view.clearSelection();
	}); 
var dropdown = selectpanel.addEmpty()
	.append("select")
	.on("focus",function(){
		classes = getAllClasses(planarmap);
		d3.select(this).selectAll("option.selectoption")
			.data(classes,function(d){ return d;})
			.enter().append("option")
			.attr("class","selectoption")
			.attr("value",function(d){ return d;})
			.text(function(d){return d;});
	})
	.on("change",function(event){
		var selectClass = this.value;
		planarmap.forEach(function(obj){
			if( obj.class[selectClass] )
			{
				view.addToSelection(obj);
			}
		});
		view.updateLayers();
		this.value = "";
		this.blur();
	})
	.append("option")
	.attr("class","selectheader")
	.text("--- Select all of class ---")
	.attr("value","");
	
var setclassDropDown = selectpanel.addEmpty();
setclassDropDown
	.append("input")
	.attr("list","selectclasses")
	.attr("value","Set class ...")
	.on("change",function(event){
		addStateToUndoHistory();
		var classname = this.value;
		view.getSelection().faces.forEach(function(f){
			f.class[classname] = true;
		});
		view.getSelection().edges.forEach(function(e){
			e.class[classname] = true;
		});
		view.getSelection().nodes.forEach(function(n){
			n.class[classname] = true;
		});		
		var selectClass = this.value;
		planarmap.forEach(function(obj){
			if( obj.class[selectClass] )
			{
				view.addToSelection(obj);
			}
		});
		view.updateLayers();
		this.value = "Set class ...";
	})
	.on("focus",function(){
		this.value = "";
		classes = getAllClasses(planarmap);
		var allowedClasses = classes.filter(function(x){
			return ["face","edge","node"].indexOf(x) < 0;
		});
		d3.select("#selectclasses").selectAll("option")
			.data(allowedClasses,function(d){ return d;})
			.enter().append("option")
			.attr("value",function(d){ return d;})
			.text(function(d){return d;});
	})
	.append("datalist")
	.attr("id","selectclasses");
	
selectpanel.addEmpty()
	.append("input").attr("type","button")
	.attr("value","Clear classes of selection")
	.on("click",function(){
		addStateToUndoHistory();
		view.getSelection().faces.forEach(function(f){
			for( var key in f.class ) {
				if(f.class.hasOwnProperty(key) && key != "face" )
				{
					f.class[key] = false;
				}
			}
		});
		view.getSelection().edges.forEach(function(e){
			for( var key in e.class ) {
				if(e.class.hasOwnProperty(key) && key != "edge" )
				{
					e.class[key] = false;
				}
			}
		});
		view.getSelection().nodes.forEach(function(n){
			for( var key in n.class ) {
				if(n.class.hasOwnProperty(key) && key != "node" )
				{
					n.class[key] = false;
				}
			}
		});				
	}); 
	
var fillcolorpicker=selectpanel.addEmpty();
fillcolorpicker
	.append("label")
	.attr("class","colorpicklabel")
	.attr("for","fillcolorpicker")
	.text("Fill:");
fillcolorpicker
	.append("input").attr("type","text")
	.attr("id","fillcolorpicker")
	.attr("class","color");
var strokecolorpicker=selectpanel.addEmpty();
strokecolorpicker
	.append("label")
	.attr("class","colorpicklabel")
	.text("Stroke:")
	.attr("for","strokecolorpicker");
strokecolorpicker	
	.append("input").attr("type","text")
	.attr("id","strokecolorpicker")
	.attr("class","color");
	
selectpanel.addEmpty()
	.append("input").attr("type","button")
	.attr("value","Clear styles of selection")
	.on("click",function(){
		addStateToUndoHistory();
		var clearstyle = function(obj){
			if( obj.attr.style )
			{
				for (var key in obj.attr.style){
					if (obj.attr.style.hasOwnProperty(key)){
						obj.attr.style[key] = null;
						//delete obj.attr.style[key];
					}
				}			
			}
		};
		view.getSelection().faces.forEach(clearstyle);
		view.getSelection().edges.forEach(clearstyle);
		view.getSelection().nodes.forEach(clearstyle);
		view.updateLayers();
	}); 	
	
function OnColorChanged(selectedColor, colorPickerIndex) {
	addStateToUndoHistory();
	view.getSelection().faces.forEach(function(f){
		if( !f.attr.style )
		{
			f.attr.style = {};
		}
		if( colorPickerIndex == 0 ) {
			f.attr.style.fill = selectedColor;
		} else if( colorPickerIndex == 1 ) {
			f.attr.style.stroke = selectedColor;
		}		
	});
	view.getSelection().nodes.forEach(function(n){
		if( !n.attr.style )
		{
			n.attr.style = {};
		}
		if( colorPickerIndex == 0 ) {
			n.attr.style.fill = selectedColor;
		} else if( colorPickerIndex == 1 ) {
			n.attr.style.stroke = selectedColor;
		}
	});
	view.getSelection().edges.forEach(function(e){
		if( !e.attr.style )
		{
			e.attr.style = {};
		}
		if( colorPickerIndex == 0 ) {
		} else if( colorPickerIndex == 1 ) {
			e.attr.style.stroke = selectedColor;
		}
	});
	view.updateLayers();		
}
	
d3.select("body").on("keydown",function(){
	if( d3.event.keyCode == 46 ) // Delete
	{
		deleteEdge();
	} else if( d3.event.keyCode == 8 ) // Backspace
	{
		performUndo();
	} else if ( d3.event.keyCode == 69 ) // E
	{
		createEdge();
	} else if ( d3.event.keyCode == 83 ) // S
	{
		splitVertexOrEdge();
	} else if ( d3.event.keyCode == 77 ) // M
	{
		toggleMarker();
	} else if ( d3.event.keyCode == 70 ) // F
	{
		fixVertices(true);
	} else if ( d3.event.keyCode == 82 ) // R
	{
		fixVertices(false);
	} else if ( d3.event.keyCode == 68 ) // D
	{
		drawDual();
	} else if ( d3.event.keyCode == 67 ) // C
	{
		startContractEdge();
	} else if ( d3.event.keyCode == 71 ) // G
	{
		startGlueEdges();
	} else if ( d3.event.keyCode >= 50 && d3.event.keyCode <= 57 ) // 2-9
	{
		createFace(d3.event.keyCode-48);
	}
});

var undoHistory = [];
function performUndo()
{
	if( undoHistory.length > 0 )
	{
		view.clearSelection();
		force.stop();
		planarmap.fromJSON(JSON.parse(undoHistory.pop()));
		planarmap.edges().forEach(function(e){
			e.attr.selected = false;
			e.attr.rightcornerselected = false;
			e.attr.leftcornerselected = false;
		});
		planarmap.faces().forEach(function(f){
			f.attr.selected = false;
		});
		planarmap.nodes().forEach(function(n){
			n.attr.selected = false;
		});	
		view.updateLayers(true);
		view.updatePositions();		
		force.resume();
	}
}
function addStateToUndoHistory()
{
	undoHistory.push( JSON.stringify(planarmap) );
}

function createEdge()
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.edges.length == 0 )	
	{
		if( selection.corners.length == 1 )
		{
			addStateToUndoHistory();
			var edge = selection.corners[0];
			view.clearSelection();
			planarmap.insertEdgeNextTo(edge);

		} else if( selection.corners.length == 2 
			&& selection.corners[0].left() ==
			   selection.corners[1].left() )
		{
			addStateToUndoHistory();
			var edge1 = selection.corners[0],
				edge2 = selection.corners[1];
			view.clearSelection();
			planarmap.insertDiagonal(edge1.left(),[edge1,edge2]);

		}
		view.updateLayers();
		view.updatePositions();
	}	
}

function splitVertexOrEdge()
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 0 &&
		selection.edges.length == 1 )	
	{
		var splitedge = selection.edges[0].getOriented();
		view.clearSelection();
		planarmap.splitEdge(splitedge);
		view.updateLayers();
		view.updatePositions();
	} else if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 2 &&
		selection.edges.length == 0 )	
	{
		if( selection.corners[0].start() ==
			selection.corners[1].start() )
		{
			var corner1 = selection.corners[0],
				corner2 = selection.corners[1];
			view.clearSelection();
			addStateToUndoHistory();
			planarmap.splitVertex([corner1,corner2]);
			view.updateLayers();
			view.updatePositions();
		}
	}	
}

function deleteEdge()
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 0 &&
		selection.edges.length == 1 )
	{
		var edge = selection.edges[0];
		if( !(edge.start.edges.length > 1 && edge.end.edges.length > 1
			&& edge.left == edge.right) && planarmap.numEdges() > 1 )
		{
			view.clearSelection();
			addStateToUndoHistory();
			planarmap.removeEdge(edge);
			view.updateLayers();
			view.updatePositions();
		}
	}
}

function toggleMarker()
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length > 0 &&
		selection.edges.length == 0 )
	{
		addStateToUndoHistory();
		selection.corners.forEach(function(oredge){
			if( !oredge.edge.attr.marker )
			{
				oredge.edge.attr.marker = {};
			}
			if( !oredge.reversed )
			{
				if( !oredge.edge.attr.marker.start || oredge.edge.attr.marker.start != "arrow" )
				{
					oredge.edge.attr.marker.start = "arrow";
				} else
				{
					oredge.edge.attr.marker.start = "";
				}
			} else
			{
				if( !oredge.edge.attr.marker.end || oredge.edge.attr.marker.end != "arrow" )
				{
					oredge.edge.attr.marker.end = "arrow";
				} else
				{
					oredge.edge.attr.marker.end = "";
				}
			}		
		});
		view.updateLayers();
	}
}

function fixVertices(fix)
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length > 0 &&
		selection.corners.length == 0 &&
		selection.edges.length == 0 )
	{
		addStateToUndoHistory();
		selection.nodes.forEach(function(node){
			if( !node.layout )
			{
				node.layout = {};
			}
			node.layout.fixed = fix;
		});
		view.updateLayers();
	}
}

function drawDual()
{
	addStateToUndoHistory();
	CMap.addDualMap(planarmap,d3.event.shiftKey);
	planarmap.edges().forEach(function(edge){
		edge.layout.relSpringLength = 0.5;
		edge.layout.relRepulsionStrength = 0.5;
	})
	view.updateLayers();
	view.updatePositions();	
}

function createFace(degree)
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 1 &&
		selection.edges.length == 0 )
	{
		addStateToUndoHistory();
		var corners = [selection.corners[0], selection.corners[0].next()];
		view.clearSelection();
		var newedges = [
			planarmap.insertDiagonal(corners[0].left(),
				[corners[0],corners[1]])
		];
		
		while( newedges.length + 1 < degree )
		{
			var longestedge;
			var longestlength = 0.0;
			newedges.forEach(function(edge){
				var length = CMap.edgeLength(edge);
				if( length > longestlength )
				{
					longestlength = length;
					longestedge = edge;
				}
			});
			planarmap.splitEdge(longestedge.getOriented());
			newedges.push( longestedge.getOriented().next().edge );
		}
		view.updateLayers();
		view.updatePositions();		
	}
}

function startContractEdge()
{
	var selection = view.getSelection();
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 0 &&
		selection.edges.length == 1 )
	{
		var edge = selection.edges[0];
		
		// make sure it's not a loop
		if( edge.start != edge.end )
		{
			addStateToUndoHistory();
			view.clearSelection();
			// use force to contract edge a bit
			edge.layout["relSpringLength"] = 0.05;
			edge.layout["relSpringCoupling"] = 8.0;
			force.resume();
			
			// then perform contraction after delay
			setTimeout(function(){
				contractEdge(edge.getOriented());
			},400);
		}
	}
}

function contractEdge(orientededge)
{
	var contractleft = true;
	while( !orientededge.isReverse( orientededge.prev() ) )
	{
		// reroute edges alternatingly on the left and the right to
		// avoid too much twisting/torque
		if( contractleft )
		{
			var nextedge = orientededge.prev();
			planarmap.insertDiagonal(nextedge.left(),
				[nextedge,orientededge.next()]);
			planarmap.removeEdge(nextedge.edge);
		} else
		{
			var nextedge = orientededge.reverse().next();
			planarmap.insertDiagonal(nextedge.left(),
				[nextedge.next(),nextedge.prev()]);
			planarmap.removeEdge(nextedge.edge);	
		}
		contractleft = !contractleft;
	}
	planarmap.removeEdge(orientededge.edge);
		
	view.updateLayers();
	view.updatePositions();		
}

function filterInPlace(a, condition) {
  var i = 0, j = 0;

  while (i < a.length) {
    const val = a[i];
    if (condition(val, i, a)) a[j++] = val;
    i++;
  }

  a.length = j;
  return a;
}

function startGlueEdges()
{
	var selection = view.getSelection();
	var edgepairs = [];
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 2 &&
		selection.edges.length == 0 )
	{
		edgepairs.push([selection.corners[0],selection.corners[1]]);
	}
	if( selection.faces.length == 0 &&
		selection.nodes.length == 0 &&
		selection.corners.length == 1 &&
		selection.edges.length == 0 )
	{
		edgepairs.push([selection.corners[0],selection.corners[0].prev()]);
	}				
	if( selection.edges.length == 2 )
	{
		edgepairs.push([selection.edges[0].getOriented(),selection.edges[1].getOriented()]);
		edgepairs.push([selection.edges[0].getOriented(true),selection.edges[1].getOriented()]);		
		edgepairs.push([selection.edges[0].getOriented(),selection.edges[1].getOriented(true)]);
		edgepairs.push([selection.edges[0].getOriented(true),selection.edges[1].getOriented(true)]);
	}				
	if( selection.faces.length == 1 && selection.edges.length == 2 )
	{
		filterInPlace(edgepairs,function(p){ return p[0].left() == selection.faces[0]; });
	}	
	if( selection.corners.length >= 1 && selection.edges.length == 2 )
	{
		filterInPlace(edgepairs,function(p){ return p[0].left() == selection.corners[0].left(); });
	}
	filterInPlace(edgepairs,function(p){ 
		return (p[0].left() == p[1].left())
			&& !p[0].isReverse(p[1])
			&& p[0] != p[1]
			&& (p[0].start() != p[1].end() || p[0].prev().isEqual(p[1]))
			&& (p[1].start() != p[0].end() || p[1].prev().isEqual(p[0])); 
		
	});
	if( edgepairs.length == 1 )
	{
		addStateToUndoHistory();
		view.clearSelection();
		var edges = edgepairs[0];
		if( !edges[0].next().isEqual(edges[1]) )
		{
			var tempedge0 = planarmap.insertDiagonal(edges[0].left(),
				[edges[0].next(),edges[1]]);
			tempedge0.class["contract"] = true;
			tempedge0.layout["relSpringLength"] = 0.05;
			tempedge0.layout["relSpringCoupling"] = 12.0;
		}
		if( !edges[1].next().isEqual(edges[0]) )
		{
			var tempedge1 = planarmap.insertDiagonal(edges[1].left(),
				[edges[0],edges[1].next()]);
			tempedge1.class["contract"] = true;
			tempedge1.layout["relSpringLength"] = 0.05;
			tempedge1.layout["relSpringCoupling"] = 12.0;
		}
		view.updateLayers();
		view.updatePositions();	
		force.resume();
	
		// then perform contraction after delay
		setTimeout(function(){
			planarmap.removeEdge(edges[1].edge);
			if( tempedge0 )
			{
				contractEdge(tempedge0.getOriented());
			}
			if( tempedge1 )
			{
				contractEdge(tempedge1.getOriented());
			}
			//planarmap.removeEdge(edges[0].edge);
			console.assert( planarmap.checkIncidence());
			view.updateLayers();
			view.updatePositions();	
		},600);
		
	}		
}

</script>
</body>
</html>

