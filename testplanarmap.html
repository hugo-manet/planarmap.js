<html>
<head>
<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	padding: 0;
}
#pmap {
	width: 100%;
	height: 100%;
	top: 0;
	left: 0;
}
.link {
	stroke: #999;
}
.forcevec {
	stroke: red;
}
svg polygon.corner {
	pointer-events: none;
	fill: #dd5020;
}
svg text.label {
	pointer-events: none;
	font-family: Verdana;
	font-size: 0.3;
}
svg path.link {
	stroke-width: 0.05;
	stroke: #aaaaaa;
	fill: none;
}
svg line.segmenthelper {
	pointer-events: none;
	stroke-width: 0.05;
	stroke: #aaaaaa;
	stroke-dasharray: 5,5;
}
svg circle.node {
	cursor:move;
}
#controls {
	z-index:101; 
	position:absolute;
	top:20px;
	right:20px;
}
#controls label {
	display: inline-block;
	width: 140px;
	text-align: right;
}
</style>
</head>
<body>
<div id="pmap">
</div>
<div id="controls">
<p>
	<label for="springCoupling">Spring coupling</label>
	<input type="range" min="0.2" max="10" id="springCoupling" value="1" step="0.2" />
	<span id="springCouplingValue">1</span>
</p>
<p>
	<label for="springLength">Spring length</label>
	<input type="range" min="0.2" max="2.5" id="springLength" value="1" step="0.1" />
	<span id="springLengthValue">1</span>
</p>
<p>
	<label for="repulsionPower">Repulsion power</label>
	<input type="range" min="0.1" max="3" id="repulsionPower" value="1" step="0.1" />
	<span id="repulsionPowerValue">1</span>
</p>
<p>
	<label for="centerPullCoupling">Center pull coupling</label>
	<input type="range" min="0" max="10" id="centerPullCoupling" value="1" step="0.25" />
	<span id="centerPullCouplingValue">1</span>
</p>
</div>
<script charset="utf-8" src="./thirdparty/d3/d3.js"></script>
<script src="geometry.js"></script>
<script src="layout.js"></script>
<script src="force.js"></script>
<script src="planarmap.js"></script>
<script>

var planarmap = CMap.PlanarMap();
var layoutupdater = CMap.LayoutUpdater()
	.registerAll(planarmap);
planarmap.singleEdgeMap();
console.assert(planarmap.checkIncidence(),"Incidence error");
console.assert(!CMap.planarMapIsNonSimple(planarmap),"non-simple");
function check(){
	console.assert(planarmap.checkIncidence(),"Incidence error");
	console.assert(!CMap.planarMapIsNonSimple(planarmap),"non-simple");
	updateFaceLayer();
	updateEdgeLayer();
	updateNodeLayer();
}
function randomInteger(min,max) {
	return Math.floor(Math.random() * (max-min+1))+min;
}

setInterval(function(){
	if( Math.random() > 0.3 )
	{
		planarmap.insertEdgeNextTo(
			planarmap.edges().random().getOriented( Math.random() < 0.5 ) );
	} else
	{
		var face = planarmap.edges().random().left;
		var index1 = randomInteger(0,face.edges.length-1);
		var index2 = randomInteger(0,face.edges.length-1);	
		planarmap.insertDiagonal(face,[index1,index2]);	
	}
	check();
	return false;
},600);

var thisedge;
/*d3.timer(function(){
	thisedge = planarmap.insertDiagonal(planarmap.faces().get("face0"),[0,1]);
	check();
	return true;
},1000);
d3.timer(function(){
	planarmap.insertEdgeNextTo(thisedge.getOriented());
	check();
	return true;
},2000);
d3.timer(function(){
	planarmap.insertEdgeNextTo(thisedge.getOriented(true));
	check();
	return true;
},3000);
d3.timer(function(){
	planarmap.insertEdgeNextTo(thisedge.getOriented(true));
	check();
	return true;
},4000);
var extedge;
d3.timer(function(){
	extedge = planarmap.insertEdgeNextTo(thisedge.getOriented(true).next());
	check();
	return true;
},5000);
d3.timer(function(){
	planarmap.insertEdgeNextTo(extedge.getOriented(true));
	check();
	return true;
},6000);
d3.timer(function(){
	planarmap.insertDiagonal(planarmap.faces().get("face1"),[2,6]);
	check();
	return true;
},7000);
d3.timer(function(){
	planarmap.insertDiagonal(planarmap.faces().get("face0"),[0,3]);
	check();
	return true;
},7000);*/

function mirrorY(pt){
	return new Vec2(pt.x,-pt.y);
}

var helplines = [];
var corners = [];

var svg = d3.select("#pmap").append("svg")
	.attr("id","pmapsvg")
	.attr("width","100%")
	.attr("height","100%")
	.attr("viewBox","-8 -5 16 10")
	.attr("preserveAspectRatio", "xMidYMid meet")
	.call(d3.behavior.zoom().on("zoom",onZoom));

var zoomGroup = svg.append("g").attr("id","zoomgroup");

function onZoom(){
	zoomGroup.attr("transform",
		"scale(" + d3.event.scale + ")");
}


var force = CMap.force(planarmap)
	.centerPull({pull: true, center: new Vec2(0,0), coupling: 0.4})
	.on("tick",updateMap)
	.on("end",updateMap);

d3.select("#springCoupling").on("input",function(){updateSpringCoupling(+this.value);});
function updateSpringCoupling(x) {
	force.springCoupling(x);
	d3.select("#springCoupling").property("value",x);
	d3.select("#springCouplingValue").text(x);
	force.resume();	
}	
d3.select("#springLength").on("input",function(){updateSpringLength(+this.value);});
function updateSpringLength(x) {
	force.springLength(x);
	d3.select("#springLength").property("value",x);
	d3.select("#springLengthValue").text(x);
	force.resume();		
}	
d3.select("#repulsionPower").on("input",function(){updateRepulsionPower(+this.value);});
function updateRepulsionPower(x) {
	force.repulsionPower(x);
	d3.select("#repulsionPower").property("value",x);
	d3.select("#repulsionPowerValue").text(x);	
	force.resume();	
}
d3.select("#centerPullCoupling").on("input",function(){updateCenterPullCoupling(+this.value);});
function updateCenterPullCoupling(x) {
	force.centerPull().coupling = x;
	d3.select("#centerPullCoupling").property("value",x);
	d3.select("#centerPullCouplingValue").text(x);	
	force.resume();	
}			

var backgroundLayer = zoomGroup.append("g").attr("class","backgroundLayer");
var backgroundRect = backgroundLayer.append("rect")
	.attr("fill","white")
	.attr("width","100%").attr("height","100%").attr("x",0).attr("y",0)
//	.on("mouseout",function() { removeCorners(); d3.select(this).style("fill","white");})
//	.on("mousemove",function(){ polygonMouseMove(externalface);} )
//	.on("mousedown",function(){ polygonMouseDown(externalface);} )
//	.on("mouseup",function(){ polygonMouseUp(externalface);} );

var faceLayer = zoomGroup.append("g").attr("class","faceLayer");

var cornerLayer = zoomGroup.append("g").attr("class","cornerLayer");

var edgeLayer = zoomGroup.append("g").attr("class","edgeLayer");

var helpLineLayer = zoomGroup.append("g").attr("class","helpLineLayer");

var nodeLayer = zoomGroup.append("g").attr("class","nodeLayer");

var drag = d3.behavior.drag()
	.origin(function(d){return d;})
	.on("drag", dragmove)
	.on("dragstart", dragstart)
	.on("dragend", dragend);

var segmentStartCorner = {};

function updateFaceLayer()
{
	var facePolygons = faceLayer.selectAll("path")
		.data(planarmap.faces().array().filter(function(f) { return !f.layout.outer; }),
			function(f){ return f.uid; });
	
	facePolygons.enter().append("path")
		.attr("fill","lightblue" )
		.attr("stroke","")
	//	.on("mouseout",function(d,i) { removeCorners(); d3.select(this).style("fill","white");})
	//	.on("mousemove",polygonMouseMove)
	//	.on("mousedown",polygonMouseDown)
	//	.on("mouseup",polygonMouseUp)
		
	facePolygons.exit().remove();
}

/*
function updateCornerLayer()
{
	var cornerPolygons = cornerLayer.selectAll("polygon")
		.data(corners);
	
	cornerPolygons.enter()
		.append("polygon")
		.attr("class","corner")
		.attr("points",cornerPolygonPoints);
		
	cornerPolygons.exit().remove();
}*/

function updateEdgeLayer()
{
	var edgePaths = edgeLayer.selectAll("path")
		.data(planarmap.edges().array(),
			function(e){return e.uid;});
		
	edgePaths.enter().append("path")
		.attr("class","link");
	
	edgePaths.exit().remove();
}

function updateHelpLineLayer()
{
	var helpLines = helpLineLayer.selectAll("line")
		.data(helplines);
		
	helpLines.enter().append("line")
		.attr("class",function(d){ return d.ofclass;} );
	
	helpLines.exit().remove();
}

function updateNodeLayer()
{
	var nodeGroups = nodeLayer.selectAll("g.node")
		.data(planarmap.nodes().array(),
			function(n){return n.uid;}
		);
		
	var newNodeGroups = nodeGroups.enter().append("g")
		.attr("class","node");
		
	newNodeGroups.append("circle")
	   	.attr("class","node")
	   	.attr("r","0.1")
	   	.attr("fill", "blue")
	 	.call(drag);		

	newNodeGroups.append("text")
		.attr("dx",0.14)
		.attr("dy",-0.1)
		.attr("class","label")
		.style("text-anchor","start")
		.text(function(d,i) {return i;});
		
	nodeGroups.exit().remove();
}

updateFaceLayer();
//updateCornerLayer();
updateEdgeLayer();
updateNodeLayer();

function dragstart(d)
{
	force.dragforce().drag = true;
	force.dragforce().node = d;
	
	var p = d3.mouse(d3.select("#zoomgroup").node());
	force.dragforce().cursor = new Vec2(p[0],-p[1]);

	force.resume();
}
function dragmove(d)
{
	var p = d3.mouse(d3.select("#zoomgroup").node());
	force.dragforce().cursor = new Vec2(p[0],-p[1]);
	force.resume();
}
function dragend(d)
{
	force.dragforce().drag = false;
}

function cornerRadius(angle)
{
	return Math.max(0.35,Math.min(1.3,0.3/angle));
}
/*
function polygonMouseMove(d)
{
	d3.event.preventDefault();

	if( force.dragforce().drag )
	{
		return;
	}
	var p = d3.mouse(svg.node());
	var mouse = fromScreenCoor({x:p[0],y:p[1]});	
	if( !segmentStartCorner.face || segmentStartCorner.face == d )
	{

		var mindistSq = 1000;
		var minnode = 0;
		var mincorner = 0;
		var minangle = 10;
		d.links.forEach(function(l,i){
			var thisnode = links[l.id][l.ccw?0:1];
			var distSq = mouse.copy().subVec( nodes[thisnode].pos ).normSq();
			if( !nodes[thisnode].auxiliary && distSq < mindistSq )
			{
				var prevlink = d.links[(i+d.links.length-1)%d.links.length];
				var prev = nodes[links[prevlink.id][prevlink.ccw?0:1]].pos.copy().subVec(nodes[thisnode].pos);
				var next = nodes[links[d.links[i].id][d.links[i].ccw?1:0]].pos.copy().subVec(nodes[thisnode].pos);
				var curvec = mouse.copy().subVec( nodes[thisnode].pos );
				var angle1 = next.angle(curvec),
					angle2 = next.angle(prev);
				if( angle1 <= 0.001 ) angle1 += 2*Math.PI;
				if( angle2 <= 0.001 ) angle2 += 2*Math.PI;
				if( angle1 < angle2 )
				{
					mindistSq = distSq;
					minnode = thisnode;
					mincorner = i;
					minangle = angle2;
				}
			}
		});
		
		if( mindistSq < Math.pow(cornerRadius(minangle),2) )
		{
			var prevlink = d.links[(mincorner+d.links.length-1)%d.links.length];
			var prevnode = links[prevlink.id][prevlink.ccw?0:1];
			var nextnode = links[d.links[mincorner].id][d.links[mincorner].ccw?1:0];

			if( corners.length == 0 )
			{
				corners[0] = { c: nodes[minnode], r: 0.4, prev: nodes[prevnode], next: nodes[nextnode], 
					face: d, faceindex: mincorner, nodeindex: minnode };
			} else
			{
				corners[0].c = nodes[minnode];
				corners[0].r = 0.4;
				corners[0].prev = nodes[prevnode];
				corners[0].next = nodes[nextnode];
				corners[0].face = d;
				corners[0].faceindex = mincorner;
				corners[0].nodeindex = minnode;
			}
			updateCornerLayer();
			force.resume();
		} else
		{
			removeCorners();
		}
	}
	
	if( segmentStartCorner.face )
	{
		if( helplines.length == 0 )
		{
			helplines[0] = { p1: segmentStartCorner.c.pos, p2: mouse.copy(), ofclass: "segmenthelper" };
			updateHelpLineLayer();
		} else
		{
			helplines[0].p1 = segmentStartCorner.c.pos;
			helplines[0].p2 = mouse.copy();
			updateHelpLineLayer();
		}
		force.resume();
	} else 
	{
		removeHelpLines();
	}
	

}

function polygonMouseDown(d)
{
	d3.event.preventDefault();
	if( corners.length == 1 )
	{
		segmentStartCorner.c = corners[0].c;
		segmentStartCorner.face = corners[0].face;		
		segmentStartCorner.faceindex = corners[0].faceindex;
		segmentStartCorner.nodeindex = corners[0].nodeindex;		
	} else
	{
		segmentStartCorner = {};
	}
}

function polygonMouseUp(d)
{
	if( corners.length == 1 && segmentStartCorner.face && segmentStartCorner.face == corners[0].face )
	{
		if( segmentStartCorner.faceindex != corners[0].faceindex)
		{
			splitFace([segmentStartCorner,corners[0]]);	
		} else
		{
			insertEdge(corners[0]);
		}
	}
	segmentStartCorner = {};
	removeHelpLines();
}

function insertEdge(corner)
{
	var nextvec = corner.next.pos.copy().subVec(corner.c.pos);
	var prevvec = corner.prev.pos.copy().subVec(corner.c.pos);
	var angle = nextvec.angle(prevvec);
	if( angle <= 0.001 ) angle += 2*Math.PI;
	
	var newcoor = nextvec.rotate(0.5*angle).mult(0.6).addVec(corner.c.pos);
	nodes.push({pos: newcoor});
	links.push([corner.nodeindex,nodes.length-1]);
	edges.push([links.length-1]);
	corner.face.links.splice(corner.faceindex,0,{id:links.length-1,ccw:true},{id:links.length-1,ccw:false});
	
	while( CMap.faceIsNonSimple(corner.face,links,nodes) )
	{
		newcoor.subVec(corner.c.pos).mult(0.6).addVec(corner.c.pos);
	}
	
	updateFaceLayer()
	updateLinkLayer();
	updateNodeLayer();
	
	removeCorners();
	force.resume();
}

function splitFace(corners)
{
	var thisface = corners[0].face.links.map(function(l){
		return (l.ccw? nodes[links[l.id][0]].pos : nodes[links[l.id][1]].pos );
	});
	
	var c = ( corners[0].faceindex < corners[1].faceindex ? 
		[ corners[0], corners[1] ] : [ corners[1], corners[0] ] );
	
	var path = [];
	if( !c[0].face.outer )
	{
		if( thisface.length == 3 )
		{
			path = [thisface[0].copy().addVec(thisface[1]).addVec(thisface[2]).divide(3)];
		} else if( !c[0].face.outer )
		{
			path = CMap.findPathInPolygon(thisface,[c[0].faceindex,c[1].faceindex]);
		} 
	} else 
	{
		if( !CMap.isProperDiagonal(thisface,[c[0].faceindex,c[1].faceindex]) )
		{
			// Construct a bounding box
			var boundingbox = {min: new Vec2(-1,-1), max: new Vec2(1,1)};
			thisface.forEach(function(p){
				if( p.x < boundingbox.min.x ) boundingbox.min.x = p.x;
				if( p.y < boundingbox.min.y ) boundingbox.min.y = p.y;
				if( p.x > boundingbox.max.x ) boundingbox.max.x = p.x;
				if( p.y > boundingbox.max.y ) boundingbox.max.y = p.y;
			});
			var center = boundingbox.max.copy().addVec(boundingbox.min).mult(0.5);
			boundingbox.min.subVec(center).mult(1.4).addVec(center);
			boundingbox.max.subVec(center).mult(1.4).addVec(center);
			var box = [ boundingbox.min, 
						new Vec2(boundingbox.max.x, boundingbox.min.y),
						boundingbox.max,
						new Vec2(boundingbox.min.x, boundingbox.max.y) ];
			
			// Choose the vertex furthest away from the corners c
			var distance = 0;
			var index = 0;
			thisface.forEach(function(p,i){
				var d = p.copy().subVec(c[0].c.pos).norm() + p.copy().subVec(c[1].c.pos).norm();
				if( d > distance )
				{
					distance = d;
					index = i;
				}
			});
			
			var next = thisface[(index+1)%thisface.length];
			var prev = thisface[(index+thisface.length-1)%thisface.length];
			var normal = thisface[index].copy().subVec(prev);
			if( next != prev )
			{
				normal = next.copy().subVec(thisface[index]).getBisector(prev.copy().subVec(thisface[index]));
			}
			// Rearrange box to line up with the normal
			if( normal.x <= 0 && normal.y > 0 )
			{
				box.unshift(box.pop());
			} else if( normal.x > 0 )
			{
				box.push(box.shift());
				if( normal.y > 0 )
				{
					box.push(box.shift());
				}
			}
			thisface.splice(index,0,thisface[index],
				box[0], box[0].copy().addVec(box[1]).mult(0.5),
				box[1], box[1].copy().addVec(box[2]).mult(0.5),
				box[2], box[2].copy().addVec(box[3]).mult(0.5),
				box[3], box[3].copy().addVec(box[0]).mult(0.5),
				box[0]);
			path = CMap.findPathInPolygon(thisface,
				[c[0].faceindex + (c[0].faceindex > index ? 10 : 0)
				,c[1].faceindex + (c[1].faceindex > index ? 10 : 0)]);
		}
	}

	var firstNodeId = nodes.length;
	path.forEach(function(p){ 
		nodes.push({pos: p, auxiliary: true});
	});
	
	edges.push([]);
	var firstLinkId = links.length;
	for(var i=0;i<=path.length;i++)
	{
		links.push([ i==0 ? c[0].nodeindex : firstNodeId+i-1,
					 i==path.length ? c[1].nodeindex : firstNodeId+i ]);
		edges[edges.length-1].push(links.length-1);
	}
	faces.push({links: 
		c[0].face.links.splice(c[0].faceindex,c[1].faceindex-c[0].faceindex),
		outer: false,
		color: c[0].face.color});
	for(var i=path.length;i>=0;i--)
	{
		faces[faces.length-1].links.push({id: firstLinkId + i, ccw: false});
		c[0].face.links.splice(c[0].faceindex,0,{id: firstLinkId + i, ccw: true});
	}
	
	if( c[0].face.outer )
	{
		var angle = CMap.faceAngleSum(c[0].face,links,nodes);
		if( Math.abs(angle-(c[0].face.links.length-2)*Math.PI) < 0.1 )
		{
			// the previously outer face is not the outer face anymore
			c[0].face.outer = false;
			faces[faces.length-1].outer = true;
			externalface = faces[faces.length-1];
		}
	}
		
	updateFaceLayer();
	updateLinkLayer();
	force.resume();
}
*/


function removeHelpLines()
{
	if( helplines.length > 0 )
	{
		while( helplines.length > 0 )
		{
			helplines.pop();
		}
		updateHelpLineLayer();
	}
}
/*
function removeCorners()
{
	//if( removeCorners.length > 0 )
	//{
		while(corners.length > 0) {
			corners.pop();
		}
		updateCornerLayer();
	//}
}

function cornerPolygonPoints(corner)
{
	var coor = [];
	coor.push(corner.c.pos);
	var radial=corner.next.pos.copy().subVec(corner.c.pos).normalize();
	var angle = radial.angle(corner.prev.pos.copy().subVec(corner.c.pos));
	if( angle <= 0.0001 ) angle += 2*Math.PI;
	
	radial.mult(cornerRadius(angle));
	var subdiv = Math.ceil(angle/0.2);
	for( var i=0;i<=subdiv;i++)
	{
		coor.push(radial.copy().rotate(i*angle/subdiv).addVec(corner.c.pos));
	}
	return coor.map(function(p) {
		var scr = toScreenCoor(p);
		return [scr.x,scr.y].join(","); }).join(" ");
}
*/
function roundCornerPath(path,radius,includeMoveTo)
{
	includeMoveTo = defaultFor(includeMoveTo,true);
	function coorstr(p) { 
		return p.x + " " + (-p.y);
	}
	var p = (includeMoveTo?"M " + coorstr(path[0]):"");
	
	for(var i=1;i<path.length-1;i++)
	{
		var prev = path[i-1].minus(path[i]);
		var next = path[i+1].minus(path[i]);
		var thisradius = Math.min(radius,Math.min(prev.norm()/2,next.norm()/2));
		prev.normalize().mult(thisradius).addVec(path[i]);
		next.normalize().mult(thisradius).addVec(path[i]);
		p += " L " + coorstr(prev) + " Q " + coorstr(path[i]) + " " + coorstr(next);
	}
	p += " L " + coorstr(path[path.length-1]);
	return p;
}

function updateMap()
{
	var cornersize = 0.5;
	nodeLayer.selectAll("g.node").attr("transform", function(d){
		return "translate(" + d.pos.x + "," + (-d.pos.y) + ")";
   	});

	edgeLayer.selectAll("path")
		.attr("d", function(edge) {
			var coor = CMap.getVerticesOnEdge(edge.getOriented(),true,true)
				.map(function(v){return v.pos;});
			return roundCornerPath(coor, cornersize);
		});
	
	//cornerLayer.selectAll("polygon")
	//	.attr("points",cornerPolygonPoints);
	
	helpLineLayer.selectAll("line")
		.attr("x1", function(d) { return d.p1.x; })
		.attr("y1", function(d) { return -d.p1.y; })
		.attr("x2", function(d) { return d.p2.x; })
		.attr("y2", function(d) { return -d.p2.y; });

	faceLayer.selectAll("path")
		.attr("d",function(d) {
			var first = true;
			return d.edges.map(function(edge){
					var coor = CMap.getVerticesOnEdge(edge,true,true)
						.map(function(v){return v.pos;});
					var path = roundCornerPath(coor, cornersize, first);
					first = false;
					return path;
				}).join(" ");
			});

}

updateSpringCoupling(1);
updateSpringLength(1);
updateRepulsionPower(1);


</script>
</body>
</html>
